<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>issue-truck</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://issue-truck.github.io///posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="issue-truck" data-gatsby-head="true"/><meta property="og:title" content="issue-truck" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://issue-truck.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://issue-truck.github.io///posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="issue-truck" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | issue-truck" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-K51EWLBL7C"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-K51EWLBL7C');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-30ddb52b49381362.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/ZKJhj86Ua9Vhgqjyv7j_B/_buildManifest.js" defer=""></script><script src="/_next/static/ZKJhj86Ua9Vhgqjyv7j_B/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Issue Truck</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="가장 안전한 Nodejs 인증 API 만들기 최적의 방법들" href="/post/2024-07-01-CraftingtheMostSecureAuthenticationAPIinNodejsBestPractices"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가장 안전한 Nodejs 인증 API 만들기 최적의 방법들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-CraftingtheMostSecureAuthenticationAPIinNodejsBestPractices_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가장 안전한 Nodejs 인증 API 만들기 최적의 방법들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Issue Truck</span></div><strong class="PostList_title__loLkl">가장 안전한 Nodejs 인증 API 만들기 최적의 방법들</strong><div class="PostList_meta__VCFLX"><span class="date">3 hours ago</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Express 앱을 Firestore와 연동하여 Choreo에 배포하는 방법" href="/post/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Express 앱을 Firestore와 연동하여 Choreo에 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Express 앱을 Firestore와 연동하여 Choreo에 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Issue Truck</span></div><strong class="PostList_title__loLkl">Express 앱을 Firestore와 연동하여 Choreo에 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">3 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Zoneless Angular 앱에서 NgRx SignalStore 상태 관리 방법" href="/post/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Zoneless Angular 앱에서 NgRx SignalStore 상태 관리 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Zoneless Angular 앱에서 NgRx SignalStore 상태 관리 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Issue Truck</span></div><strong class="PostList_title__loLkl">Zoneless Angular 앱에서 NgRx SignalStore 상태 관리 방법</strong><div class="PostList_meta__VCFLX"><span class="date">3 hours ago</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular v18  redirectTo 기능을 사용한 URL 리다이렉션 방법 " href="/post/2024-07-01-Angularv18FunctionalRedirectionusingredirectTo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular v18  redirectTo 기능을 사용한 URL 리다이렉션 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-Angularv18FunctionalRedirectionusingredirectTo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular v18  redirectTo 기능을 사용한 URL 리다이렉션 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Issue Truck</span></div><strong class="PostList_title__loLkl">Angular v18  redirectTo 기능을 사용한 URL 리다이렉션 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">3 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="undefined" href="/post/undefined"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="undefined" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/undefined_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="undefined" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">Issue Truck</span></div><strong class="PostList_title__loLkl">undefined</strong><div class="PostList_meta__VCFLX"><span class="date">May 17, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/posts/1">1</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"가장 안전한 Nodejs 인증 API 만들기 최적의 방법들","description":"","date":"2024-07-01 20:43","slug":"2024-07-01-CraftingtheMostSecureAuthenticationAPIinNodejsBestPractices","content":"\n\n\"마크다운 형식으로 테이블 태그를 변경해주세요.\"","ogImage":{"url":"/assets/img/2024-07-01-CraftingtheMostSecureAuthenticationAPIinNodejsBestPractices_0.png"},"coverImage":"/assets/img/2024-07-01-CraftingtheMostSecureAuthenticationAPIinNodejsBestPractices_0.png","tag":["Tech"],"readingTime":1},{"title":"Express 앱을 Firestore와 연동하여 Choreo에 배포하는 방법","description":"","date":"2024-07-01 20:42","slug":"2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo","content":"\n\n## 데이터베이스 통합 및 Choreo 플랫폼에 배포하는 단계별 가이드\n\n![이미지](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_0.png)\n\n이 블로그 포스트에서는 Express.js를 사용하여 서버를 생성하고 프로젝트 세부 정보를 저장할 간단한 데이터베이스와 통합하는 과정을 안내합니다. 그 후에는 Choreo 플랫폼에 배포할 것입니다. 데이터베이스로는 Cloud Firestore를 사용할 것입니다.\n\n![이미지](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기술 개요\n\nExpress.js는 간결하고 유연한 Node.js 프레임워크로, 강력한 기능과 미들웨어 지원을 통해 서버 측 애플리케이션의 작성을 간소화합니다. Firebase의 NoSQL 문서 데이터베이스 인 Cloud Firestore와 결합되어 있습니다. Choreo는 API 관리, 이벤트 스트리밍 및 마이크로서비스 통합을 제공하여 통합을 간편화합니다. WSO2가 개발한 이 직관적인 플랫폼은 스리랑카의 주요 소프트웨어 회사로, 애플리케이션의 배포 및 관리를 단순화하여 프로젝트를 구축하고 확장하기가 이전보다 쉬워집니다.\n\n## 프로젝트 설정하기\n\n코드에 들어가기 전에 다음 항목이 설치되어 있는지 확인하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기기에 Node.js와 npm을 설치해주세요\n- Firebase 계정 (Firebase에서 가입하세요)\n- Choreo 계정 (Choreo에서 가입하세요)\n- Github 계정\n\n이 튜토리얼에서는 다음 주요 단계를 다룰 예정입니다:\n\n- Express.js 설정\n- Firebase Admin SDK 초기화\n- Firebase GET 및 POST 작업을 위한 라우트 추가\n- Choreo에 배포하기\n\n# 단계 01: Express.js 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트 초기화하기\n\n우선, 프로젝트를 위한 새 디렉토리를 만들어주세요. 터미널이나 명령 프롬프트를 열고 프로젝트를 생성하고 싶은 디렉토리로 이동해주세요. 그런 다음, 다음 명령어를 실행해주세요:\n\n```js\nnpm init -y\n```\n\n- Express 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress를 설치하려면 npm을 사용하면 됩니다. 이 명령은 Express를 프로젝트에 설치합니다.\n\n```js\nnpm install express\n```\n\n- Express 앱 만들기\n\nExpress 애플리케이션을 위한 새 파일을 생성하세요. 예를 들어, 프로젝트의 루트 디렉토리에 app.js 또는 index.js와 같은 파일을 만들어주세요. Express를 요구하고 앱의 인스턴스를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_2.png\" /\u003e\n\n# 단계 02: Firebase Admin SDK 초기화\n\n- Firebase 프로젝트 설정:\n\nFirebase 콘솔로 이동하여 새 프로젝트를 만들고 웹 앱을 추가하세요. 추가적인 정보 및 자세한 설정 지침은 Firebase 웹 앱을 위한 Firebase 설정에 대한 공식 문서인 Firebase 웹 설정 가이드를 참조해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서비스 계정 키 생성하기:\n\n파이어베이스 콘솔의 프로젝트 설정으로 이동한 후, \"서비스 계정\"으로 이동하여 \"새 비공개 키 생성\"을 클릭합니다. 이 동작은 애플리케이션을 Firebase 서비스와 안전하게 인증하는 데 필수적인 JSON 키 파일을 생성합니다. 이 파일을 다운로드하여 프로젝트 디렉토리에 안전하게 저장하세요.\n\n- 익스프레스 앱에서 Firebase Admin SDK 설정하기:\n\n먼저, npm을 사용하여 Firebase Admin SDK npm 패키지를 설치합니다. 이 명령어는 Firebase Admin SDK 패키지를 설치하고, 서버 측에서 Firebase 서비스에 액세스할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install --save firebase-admin  \n```\n\n그런 다음 JSON 파일에서 서비스 계정 자격 증명을로드하고 Firebase Admin SDK를 초기화합니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_3.png\" /\u003e\n\n초기화되면 Firebase Admin SDK 메서드를 사용하여 Firestore와 상호 작용할 수 있습니다. Firebase에서 클라우드 firestore 데이터베이스를 만들고 project_id에서 databaseURL을 추가하려면 이것을 사용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 03: Firebase GET 및 POST 작업을 위한 라우트 추가\n\n이 단계에서는 Express 애플리케이션에 Firestore와 GET 및 POST 작업을 수행하기 위한 라우트를 추가할 것입니다.\n\n## GET 엔드포인트 (\"/projects\")\n\n\u003cimg src=\"/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## POST Endpoint (“/projects”)\n\n포스트 메소드를 설정하기 전에, Express 애플리케이션이 JSON 요청 바디를 효과적으로 처리할 수 있도록 하는 것이 중요합니다. 이를 위해, JSON 및 URL 인코딩된 요청 바디를 파싱하기 위한 미들웨어인 body-parser를 사용할 것입니다. 먼저, npm을 사용하여 body-parser를 설치해야 합니다:\n\n```js\nnpm install --save body-parser\n```\n\n그런 다음, 이러한 기능은 프로젝트의 index.js 파일 내에서 구현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_5.png)\n\n이제 Firestore에 프로젝트를 추가하기 위한 POST 메소드 설정에 대해 알아봅시다.\n\n![Image](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_6.png)\n\nPostman 또는 Insomnia와 같은 도구를 사용하여 서버에 HTTP 요청을 보내고 기능을 확인할 수 있습니다. 이 예제에서는 Insomnia를 통해 서버 엔드포인트와 상호 작용하기 위해 HTTP 요청을 보냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에 클라우드 Firestore 데이터베이스가 표시됩니다.\n\nFirebase GET 및 POST 작업에 대한 루트를 추가하는 세 번째 단계를 완료하였으므로, 이제 Choreo에 배포하는 최종 단계로 진행하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 04: Choreo에서 배포하기\n\nGitHub 계정을 설정하고 서비스 구현이 포함된 저장소를 만들었다면, Choreo를 사용하여 애플리케이션을 배포하는 방법을 따르세요.\n\n이 프로세스는 Choreo 플랫폼으로 서비스를 배포하는 것을 간소화할 것입니다.\n\n1. 프로젝트 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_9.png)\n\n2. Create a service component\n\nOn the project home page, click Service under create a component.\n\n![Image 2](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_10.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n· GitHub 탭으로 이동해서 레포지토리 URL을 추가해주세요.\n\nChoreo가 귀하의 GitHub 계정에 연결할 수 있도록 하려면 'GitHub와 인증'을 클릭하세요. Choreo에 GitHub 레포지토리를 연결하지 않았다면, 사전 준비 단계에서 생성한 GitHub 자격 증명을 입력하고 Choreo GitHub 앱을 설치할 레포지토리를 선택해주세요.\n\n![이미지](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_11.png)\n\n· NodeJS 빌드팩을 선택해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n· NodeJS 프로젝트 디렉토리 설정\n\n배포 과정의 일환으로 endpoints.yaml 파일을 생성해야 합니다. 이 파일은 Express 앱이 연결해야 하는 외부 서비스의 세부 정보(데이터베이스 또는 API 등)를 지정하는 데 사용됩니다. 더 알아보기.\n\n![file](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_12.png)\n\n파일 디렉토리 = `.choreo/endpoints.yaml`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트에 openapi.yaml 파일을 만들어주세요.\n\nopenapi.yaml 파일을 생성하는 것은 표준화된 API 문서, 자동화된 테스트, 유효성 검사, 클라이언트 라이브러리 생성을 위해 중요합니다. 이는 일관된 API 설계를 보장하며 다양한 도구와 통합되어 배포 자동화 및 API 관리의 간소화로 이어지며, 사용성을 향상시킵니다.\n\nopenapi.yaml 파일에서 일관성을 유지하기 위해 Swagger Editor와 같은 온라인 도구를 사용하세요. Swagger Editor는 실시간 피드백을 제공하고 오류를 강조해줍니다. Swagger Editor에서 엔드포인트를 실행할 때 \"Failed to fetch\" 오류가 발생할 수 있는데, 이는 CORS 문제 때문일 수 있습니다. 프로젝트에 cors 패키지를 설치하고 Express.js 앱을 업데이트하여 cors 미들웨어를 사용하면 엔드포인트의 원활한 실행을 보장할 수 있습니다.\n\n![이미지](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작업이 완료되면 변경 내용을 저장소로 푸시하고 다음 단계로 진행할 수 있습니다.\n\n- 생성을 클릭하세요.\n\nNodeJS 빌드팩을 사용하여 서비스 구성 요소를 성공적으로 생성했습니다. 이제 서비스를 빌드하고 배포해 봅시다.\n\n![이미지](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 빌드 및 배포\n\n## 빌드\n\n서비스를 빌드하려면 다음 단계를 따르세요:\n\n1. 프로젝트 홈페이지에서 Component Listing 아래에 나열된 Book List 구성 요소를 클릭하십시오. 이렇게 하면 구성 요소 개요 페이지로 이동됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 왼쪽 네비게이션에서 'Build'를 클릭해주세요.\n\n3. 'Build Latest'를 클릭하세요.\n\n빌드 프로세스가 완료되면 빌드 상태가 'Success'로 변경됩니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_15.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 배포\n\n이제 서비스를 배포할 준비가 되었습니다. 다음 단계를 따르세요:\n\n1. 왼쪽 네비게이션 메뉴에서 배포를 클릭하세요.\n\n2. 설정 카드에서 구성 및 배포를 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 환경 구성 창에서 '다음'을 클릭해주세요.\n\n4. 파일 마운트 창에서 '다음'을 클릭해주세요.\n\n5. 엔드포인트 세부 정보를 확인하고 '배포'를 클릭해주세요.\n\n![image](/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_16.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n이 블로그를 통해 프로젝트를 관리하기 위해 클라우드 Firestore와 통합된 Express.js 서버를 설정하는 방법을 안내했습니다. REST API 엔드포인트를 생성하고 어플리케이션을 Choreo에 배포하여 확장성과 효율적인 클라우드 기반 작업을 가능케 했습니다. 이러한 기술은 클라우드 데이터베이스 솔루션을 효과적으로 활용하여 강력한 서버 측 응용 프로그램을 구축할 수 있는 능력을 갖추게 해 줍니다.\n\n# 참고 자료\n\n- wso2.com/choreo/docs\n- deploy-your-first-service\n- configure-endpoints\n- firebase.google.com\n- firestore\n- cors.html\n- OpenAPI Specification\n- Swagger editor\n- projectManaging_Choreo","ogImage":{"url":"/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_0.png"},"coverImage":"/assets/img/2024-07-01-BuildExpressAppwithFirestoreandDeployonChoreo_0.png","tag":["Tech"],"readingTime":7},{"title":"Zoneless Angular 앱에서 NgRx SignalStore 상태 관리 방법","description":"","date":"2024-07-01 20:39","slug":"2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp","content":"\n\n![2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png](/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png)\n\n여러분은 이미 새로운 Angular 도구인 Signals에 대해 알고 있을 것입니다. 내 의견으로는, 이는 매우 강력하고 편리한 도구로, 컨트롤러의 코드 양을 줄이고 개발 과정을 더 빠르게 만들어줍니다. 동시에, NgRx가 제안하는 상태 관리를 위한 또 다른 도구에 대해 이야기해보고 싶습니다. 이 방식을 사용하면 뷰 컨트롤러에 코드가 적어지며 페이지 효율성이 높아지고, 컨트롤러에서 부작용을 처리할 필요가 없으며 zoneless입니다. 또한 상태 관리가 만병통치약이 아니라는 것을 기억해야 하며, 필요한 프로젝트에서만 사용해야 합니다. 그렇지 않으면 페이지/프로젝트에 복잡성만 더할 수 있습니다.\n\n# 사례 설명\n\n서버에서 가져온 책 목록이 있는 상황을 상상해보겠습니다. 이들을 상태로 유지하고, 제거하거나 책을 추가할 수 있는 페이지에 표시하는 작업을 수행해야 합니다(NgRx 문서에서 가져온 케이스입니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 할 수 있는 일은 무엇일까요? 우리는 모든 복잡성을 갖춘 NgRx 스토어를 사용할 수 있고, ngneat/elf store와 같은 더 간단한 솔루션을 사용할 수도 있어요. 이러한 기술을 사용하면 여전히 데이터 스트림(옵저버블)과 zone.js와 함께 작업할 것이지만, Angular의 마지막 18번째 버전은 zoneless change detection 접근 방식을 제안하고 있어요. 네, 현재는 실험적인 부분이라고 할 수 있지만, Ivy의 경우를 상기해보세요. Angular 8에서는 선택 사항이었지만, Angular 9에서는 표준이 되었고 View Engine을 사용하려면 다시 거슬러 올라가야 했어요. 그래서, 지금부터는 이 공개된(NgRx 팀이 발표한) 새로운 도구를 사용해 보려고 해요 (이 글을 작성하는 시점에는 RC 상태에요). 이제부터는 더 많은 코드와 간결한 설명으로 진행할게요 :)\n\n이 글에서 설명된 방법은 NgRx SignalStore 문서에서 영감을 받았어요.\n\n# 가짜 DataService 구현\n\n서버에서 책 목록을 반환, 추가, 삭제하는 DataService가 있어요. 우리의 경우에는 서버 요청 수명을 흉내내기 위해 하드 코딩된 책 목록과 지연된 응답이 있는 서비스가 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {Injectable} from \"@angular/core\";\nimport {delay, map, Observable, of} from \"rxjs\";\nimport {IBook} from \"../interfaces/book.interface\";\n\nexport interface IBook {\n    id: number,\n    name: string,\n    pageCount: number\n}\n\n@Injectable({providedIn: \"root\"})\nexport class DataService {\n\n    private books: IBook[] = [\n        {\n            id: 0,\n            name: 'Book 0',\n            pageCount: 0\n        },\n        {\n            id: 1,\n            name: 'Book 1',\n            pageCount: 0\n        },\n        {\n            id: 2,\n            name: 'Book 2',\n            pageCount: 0\n        },\n        {\n            id: 3,\n            name: 'Book 22',\n            pageCount: 0\n        },\n        {\n            id: 4,\n            name: 'Book 222',\n            pageCount: 0\n        }\n    ];\n\n    getAllBooks(): Observable\u003cIBook[]\u003e {\n        return of\u003cIBook[]\u003e(this.books).pipe(\n            delay(2000)\n        );\n    }\n\n    addBook(book: IBook): Observable\u003cIBook\u003e {\n        this.books.push(book);\n        return of(book).pipe(\n            delay(2000)\n        );\n    }\n\n    removeBook(id: number): Observable\u003cnumber\u003e {\n        const index = this.books.findIndex(x =\u003e x.id === id);\n        if(index \u003e= 0) {\n            this.books.splice(index, 1);\n        }\n\n        return of(id).pipe(\n            delay(2000)\n        )\n    }\n}\n```\n\n# BooksStore implementation\n\nLet’s start creating simple SignalStore.\n\n```js\nexport const BooksStore = signalStore(\n    withEntities\u003cIBook\u003e()\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 상태를 유지하기에 충분합니다. 이것을 어떤 컴포넌트에 주입하여 사용할 수 있습니다.\n\n```js\n@Component({\n    selector: 'app-root',\n    standalone: true,\n    template: `\n      \u003cdiv\u003e\n          @for (book of booksStore.entities(); track book.id) {\n              \u003cdiv\u003e\n                  \u003cdiv\u003e{ book.name }\u003c/div\u003e\n              \u003c/div\u003e\n          }\n      \u003c/div\u003e\n  `,\n    providers: [BooksStore]\n})\nexport class App {\n    booksStore = inject(BooksStore);\n}\n```\n\n작업은 매우 간단해 보이지만, 미들웨어로 만들면 훨씬 강력해질 것입니다. 이는 BooksStore가 데이터(우리의 경우 책 목록)를 서버와 동기화하는 책임을 져야 한다는 것을 의미합니다. DataService는 어디에서나 사용하면 안 되며 오직 BooksStore에서만 사용되어야 합니다. 이를 위해 해야 할 일을 설명해 보겠습니다.\n\n- BooksStore에 모든 책을 가져오는 함수 추가\n- BooksStore에 책을 추가하는 함수 추가\n- BooksStore에서 책을 제거하는 함수 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 스토어에 있는 모든 책을 가져오는 것을 제안합니다. 이는 BooksStore가 Angular 컴포넌트에 주입될 때 서버에서 데이터를 가져오기 시작한다는 것을 의미합니다. (엄격하게 판단하지 마세요, SignalStore 훅을 보여주기 위해 이렇게 작성되었지만, 단순히 훅에서 메서드로 이동할 수 있습니다. 책을 추가하거나 제거하는 기능처럼).\n\nonInit 훅에서 모든 책을 가져오는 BooksStore\n\n```js\nexport const BooksStore = signalStore(\n    withEntities\u003cIBook\u003e(),\n    withHooks({\n        onInit(store, dataService = inject(DataService)) {\n            dataService.getAllBooks().pipe(\n                takeUntilDestroyed(),\n                tap(books =\u003e patchState(store, setEntities(books))), \n            ).subscribe();\n        },\n        onDestroy(store) {\n            console.log('Book store destroy', store);\n        },\n    }),\n)\n```\n\n이제, 책을 추가하고 제거하는 기능을 추가해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const BooksStore = signalStore(\n    withEntities\u003cIBook\u003e(),\n    withHooks({\n        onInit(store, dataService = inject(DataService)) {\n            dataService.getAllBooks().pipe(\n                takeUntilDestroyed(), \n                // 서버에서 새 책 목록으로 상점을 패치하는 부분\n                tap(books =\u003e patchState(store, setEntities(books))),\n            ).subscribe();\n        },\n        onDestroy(store) {\n            console.log('BooksStore destroy', store);\n        },\n    }),\n    withMethods((store, dataService = inject(DataService)) =\u003e ({\n        \n        // 책 추가 함수\n        add: rxMethod\u003cIBook\u003e(\n            pipe(\n                switchMap(book =\u003e {\n                    return dataService.addBook(book).pipe(\n                        // 응답 처리를 단순화하기위한 특수 NgRx 연산자\n                        tapResponse({\n                            next: (book) =\u003e {\n                                // 상태 패치\n                                // 책이 추가 또는 업데이트 될 것임 \n                                patchState(store, addEntity(book))\n                            },\n                            error: console.error,\n                            finalize: () =\u003e console.log,\n                        })\n                    )\n                })\n            )\n        ),\n        \n        // 책 삭제 함수\n        remove: rxMethod\u003cIBook\u003e(\n            pipe(\n                switchMap(book =\u003e {\n                    return dataService.removeBook(book.id).pipe(\n                        // 응답 처리를 단순화하기위한 특수 NgRx 연산자\n                        tapResponse({\n                            next: (book) =\u003e {\n                                // 상태 패치\n                                // 책이 제거될 것임\n                                patchState(store, removeEntity(book))\n                            },\n                            error: console.error,\n                            finalize: () =\u003e console.log,\n                        })\n                    )\n                })\n            )\n        ),\n    }))\n)\r\n```\n\nSignalStore와 거의 끝났어요. 하지만, 데이터를 가져오는 동안 로딩 표시를 해야 한다면 어떻게 할까요? 상점 안에 객체가 있는 경우 (리스트가 아닌 경우) isLoading 속성을 추가하여 객체의 모든 속성이 시그널 (DeepSignal)이 되므로, 이 isLoading 속성에 신호 속성으로 액세스할 수 있습니다. 그러나 엔터티 목록이 있는 경우, SignalStore는 엔터티의 상점에서 추가 신호 속성을 추가하는 기능을 제공하지 않습니다. 이를 통해 로딩과 같은 추가 상태 또는 엔터티 목록이있는 상점의 정보에 액세스 할 수 있습니다.\n\n객체가 있는 상점을 살펴보겠습니다. 여기서는 isLoading을 신호 속성으로 추가하고 계산된 신호 속성으로 count를 추가할 수 있습니다.\n\n```js\ntype BooksState = {\n    books: IBook[];\n// 로딩을 나타내기 위한 객체의 추가 속성.\n    isLoading: boolean;\n};\n\nconst initialState: BooksState = {\n    books: [],\n    isLoading: false,\n};\n\nexport const BooksStore = signalStore(\n    // withEntities 대신 withState를 사용하여 생성된 상점\n    withState(initialState),\n\n    // 주입된 BookStore의 계산된 신호 속성 추가\n    withComputed(({ booksStore }) =\u003e ({\n        // booksCount는 BookStore의 주입된 인스턴스에서 계산된 신호 속성으로 사용 가능\n        booksCount: computed(() =\u003e booksStore().entities().length),\n    })),\n\n    withMethods((store, dataService = inject(DataService)) =\u003e ({\n        load: rxMethod\u003cvoid\u003e(\n            pipe(\n                distinctUntilChanged(),\n                //\n                tap(() =\u003e patchState(store, { isLoading: true })),\n                switchMap(() =\u003e {\n                    return dataService.getAllBooks().pipe(\n                        tapResponse({\n                            next: (books) =\u003e {\n                                patchState(store, { books })\n                            },\n                            error: console.error,\n                            finalize: () =\u003e patchState(store, { isLoading: false }),\n                        })\n                    );\n                })\n            )\n        )\n    }))\n);\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빙고를 외쳐 보세요! 우리는 SignalStore를 entities가 아닌 books라는 속성을 가진 객체와 함께 사용할 수 있습니다. 이 속성은 책의 배열인데요. 하지만 안타깝게도, 만약 add(book: IBook) 또는 update(book: IBook) 메소드를 추가한다면, books 배열에서 단일 책 항목을 패치할 수 없게 됩니다. 그래서 우리는 새로운 필터링되거나 확장된 책 배열로 booksStore.books 시그널 속성을 덮어쓸 수밖에 없습니다.\n\n다행히도, JavaScript 절을 다시 살펴본 뒤 이 문제를 해결할 수 있습니다. 다행히도 SignalStore 아키텍처를 사용하면 이 문제를 해결하고 BooksStore의 @Injectable() 동작을 유지할 수 있습니다.\n\n따라서, 이 기사를 위한 BooksStore의 최종 버전은 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport {patchState, signalStore, withHooks, withMethods} from \"@ngrx/signals\";\r\nimport {addEntity, removeEntity, setEntities, withEntities} from \"@ngrx/signals/entities\";\r\nimport {IBook} from \"../interfaces/book.interface\";\r\nimport {inject, signal} from \"@angular/core\";\r\nimport {DataService} from \"../services/data.service\";\r\nimport {rxMethod} from \"@ngrx/signals/rxjs-interop\";\r\nimport {pipe, switchMap, tap} from \"rxjs\";\r\nimport {tapResponse} from \"@ngrx/operators\";\r\nimport {takeUntilDestroyed} from \"@angular/core/rxjs-interop\";\r\n\r\n// 새로운 인스턴스가 생성될 때마다 isLoading 플래그를 가진 signalStore 컨텍스트에 isLoading을 추가하는 클래스 정의\r\nexport const BooksStore = function() {\r\n    let isLoading = signal(false);\r\n\r\n    return signalStore(\r\n        withEntities\u003cIBook\u003e(),\r\n        withHooks({\r\n            onInit(store, dataService = inject(DataService)) {\r\n                isLoading.set(true);\r\n                dataService.getAllBooks().pipe(\r\n                    takeUntilDestroyed(),\r\n                    tap(books =\u003e patchState(store, setEntities(books))),\r\n                    tap(() =\u003e isLoading.set(false))\r\n                ).subscribe();\r\n            },\r\n            onDestroy(store) {\r\n                console.log('count on destroy', store);\r\n            },\r\n        }),\r\n        withMethods((store, dataService = inject(DataService)) =\u003e ({\r\n            isLoading,\r\n            add: rxMethod\u003cIBook\u003e(\r\n                pipe(\r\n                    tap(() =\u003e isLoading.set(true)),\r\n                    switchMap(book =\u003e {\r\n                        return dataService.addBook(book).pipe(\r\n                            tapResponse({\r\n                                next: (book) =\u003e {\r\n                                    patchState(store, addEntity(book));\r\n                                },\r\n                                error: console.error,\r\n                                finalize: () =\u003e isLoading.set(false),\r\n                            })\r\n                        );\r\n                    })\r\n                )\r\n            ),\r\n            remove: rxMethod\u003cIBook\u003e(\r\n                pipe(\r\n                    tap(() =\u003e isLoading.set(true)),\r\n                    switchMap(book =\u003e {\r\n                        return dataService.removeBook(book.id).pipe(\r\n                            tapResponse({\r\n                                next: (book) =\u003e {\r\n                                    patchState(store, removeEntity(book));\r\n                                },\r\n                                error: console.error,\r\n                                finalize: () =\u003e isLoading.set(false),\r\n                            })\r\n                        );\r\n                    })\r\n                )\r\n            ),\r\n        }))\r\n    );\r\n}();\r\n```\r\n\r\nBooksStore 클래스 작성이 완료되었습니다. 이제 사용 방법을 알아보고 controller 내 코드 양이 줄어드는지 확인해봅시다.\r\n\r\n# Controller 구현\r\n\r\n```js\r\n@Component({\r\n    selector: 'app-root',\r\n    standalone: true,\r\n    template: `\r\n      @if (bookStore.isLoading()) {\r\n          \u003cdiv class=\"backdrop\"\u003e\r\n              \u003cdiv class=\"spinner\"\u003e\u003c/div\u003e\r\n          \u003c/div\u003e\r\n      }\r\n      \u003cdiv\u003e\r\n          @for (book of booksStore.entities(); track book.id) {\r\n              \u003cdiv\u003e\r\n                  \u003cdiv\u003e{ book.name }\u003c/div\u003e\r\n                  \u003cbutton (click)=\"booksStore.remove(book)\"\u003eremove book\u003c/button\u003e\r\n              \u003c/div\u003e\r\n          }\r\n          \u003cbutton (click)=\"addBook()\"\u003eAdd book\u003c/button\u003e\r\n      \u003c/div\u003e\r\n  `,\r\n    providers: [BooksStore]\r\n})\r\nexport class App {\r\n    booksStore = inject(BooksStore);\r\n\r\n    addBook() {\r\n        this.booksStore.add({\r\n            id: RandomHelper.getRandomInt(10000, 99999),\r\n            name: RandomHelper.getRandomString(5),\r\n            pageCount: 0\r\n        });\r\n    }\r\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보시다시피 상점 사용법은 꽤 간단합니다. 프로젝트 전반에 걸쳐 데이터 저장소를 사용해야 할 경우, 그것은 꽤 좋고 안정적이며 빠르게 사용할 수 있는 방법입니다. 페이지의 변경 사항은 Angular의 존리스(Zoneless) 접근 방식을 통해 자동으로 적용됩니다.\n\n```js\nbootstrapApplication(AppComponent, {\n    providers: [\n        provideExperimentalZonelessChangeDetection()\n    ]\n}).then();\n```\n\n# 그리고 한 가지 더 :)\n\n일부 Observable을 구독할 때 하는 것과 같이 변경 사항에 코드를 실행해야 할 필요가 있다면, Angular Signal 효과로 쉽게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Component({\n    selector: 'app-root',\n    standalone: true,\n    template: `\n      \u003cdiv\u003e\n          @for (book of booksStore.entities(); track book.id) {\n              \u003cdiv\u003e\n                  \u003cdiv\u003e{ book.name }\u003c/div\u003e\n                  \u003cbutton (click)=\"booksStore.remove(book)\"\u003eremove book\u003c/button\u003e\n              \u003c/div\u003e\n          }\n          \u003cbutton (click)=\"addBook()\"\u003eAdd book\u003c/button\u003e\n      \u003c/div\u003e\n  `,\n    providers: [BooksStore]\n})\nexport class App {\n    booksStore = inject(BooksStore);\n\n    constructor() {\n        effect(() =\u003e {\n            const isLoading = this.booksStore.isLoading();\n\n            if (isLoading) {\n                console.log('Books loading')\n            } else {\n                console.log('Books loaded', untracked(this.booksStore.entities()))\n            }\n        });\n    }\n\n    addBook() {\n        this.booksStore.add({\n            id: RandomHelper.getRandomInt(10000, 99999),\n            name: RandomHelper.getRandomString(5),\n            pageCount: 0\n        })\n    }\n}\n```\n\neffect()에 전달된 화살표 함수는 this.booksStore.isLoading()의 변경 사항마다 실행됩니다. untracked()로 꾸며진 this.booksStore.entities() 변경은 무시됩니다.\n\n시간 내어주셔서 감사합니다. 이 글이 누군가에게 유용하길 바랍니다. 이것이 제 첫 번째 글입니다 :)\n의견이나 질문이 있다면 댓글이나 직접 메시지로 자유롭게 남겨주세요.\n\n다음 글이 제가 작성한 다양한 형식과 데이터 서비스로 프로젝트 간에 사용할 수 있는 추상화된 스토어 로직에 관한 글이 필요하시다면 알려주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 ( git \u0026 stackblitz )\n\n- git: [https://github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach](https://github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach)\n\n- stackblitz: [https://stackblitz.com/~/github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach?file=tsconfig.json](https://stackblitz.com/~/github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach?file=tsconfig.json)\n\n![GIF](https://miro.medium.com/v2/resize:fit:1200/1*7FTwCxciVW1J0WIMOenfpA.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유용한 링크:\n\n- ngneat/elf store: [여기를 클릭하세요](https://ngneat.github.io/elf/docs/store)\n- Angular zoneless: [여기를 클릭하세요](https://angular.dev/guide/experimental/zoneless)\n- NgRx SignalStore 문서: [여기를 클릭하세요](https://ngrx.io/guide/signals/signal-store)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDeepSignal: [https://ngrx.io/api/signals/DeepSignal](https://ngrx.io/api/signals/DeepSignal)\n\nAngular Signal effect: [https://angular.dev/guide/signals#effects](https://angular.dev/guide/signals#effects)\n\nAuthor's LinkedIn: [https://www.linkedin.com/in/serhii-zhydetskyi-80a7789b/](https://www.linkedin.com/in/serhii-zhydetskyi-80a7789b/)","ogImage":{"url":"/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png"},"coverImage":"/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png","tag":["Tech"],"readingTime":16},{"title":"Angular v18  redirectTo 기능을 사용한 URL 리다이렉션 방법 ","description":"","date":"2024-07-01 20:38","slug":"2024-07-01-Angularv18FunctionalRedirectionusingredirectTo","content":"\n\n\n![image](/assets/img/2024-07-01-Angularv18FunctionalRedirectionusingredirectTo_0.png)\n\n앵귤러의 부활기 가운데, 신호, 신호 NgRx, Zoneless 및 기타 많은 새로운 기능에 대해 모두가 이야기하고 있는 것을 알 수 있습니다. 이러한 것들은 앵귤러 생태계를 활성화시킬 것이라고 약속하는 여러 흥미로운 업데이트 중 하나일 뿐입니다.\n\n하지만 이것들이 유일한 흥미로운 업데이트는 아닙니다. 앵귤러 v18에서는 여러 주목할만한 향상이 소개되었으며, 이 중 하나는 리다이렉션에 함수를 사용할 수 있는 능력인 'redirectTo'입니다. 이 기능은 개발자가 정적 문자열의 제약을 넘어서 더 복잡하고 동적인 리다이렉션 로직을 구현할 수 있도록 합니다.\n\n## 함수형 리다이렉션의 사용 시기 및 장소\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 기능이 도착했을 때 생길 수 있는 질문 중 하나는: 언제 그리고 어디에 사용해야 할까요?\n\n다음은 일부 예시입니다:\n\n- 역할 기반 리다이렉션: 사용자의 역할에 따라 응용 프로그램의 다른 부분으로 사용자를 리디렉션합니다. 예를 들어, 관리자는 대시보드로 보내지고, 일반 사용자는 홈페이지로 보내집니다.\n- 조건부 네비게이션: 구독 상태나 프로필 완성도와 같은 특정 조건에 따라 사용자를 리디렉션합니다.\n- 동적 경로: 사용자 데이터나 다른 응용 프로그램 상태를 기반으로 동적 경로를 만들어 사용자가 정확히 도착해야 하는 곳에 도착하도록 합니다.\n\n이러한 시나리오를 모두 다루는 예시를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용 사례\n\n사용자가 일반 사용자 또는 관리자로 어떻게 로그인할지를 결정할 수 있는 사용자가 있다고 상상해보세요. 그들의 역할에 따라 적절한 페이지로 리디렉션하고 싶습니다.\n\n우선 아주 간단한 AuthService로 시작하여 사용자 객체를 포함하는 신호가 포함된 것을 작성할 것입니다. 간이로 이 객체는 프론트엔드 자체에서 placeholder로 대체됩니다. 실제 시나리오에서는 외부 서비스에서 가져올 수 있습니다.\n\n```js\n// auth.service.ts\nimport { Injectable, inject, signal } from '@angular/core';\nimport { Router } from '@angular/router';\n\nexport const Roles = {\n  User: 'user',\n  Admin: 'admin',\n} as const;\n\nexport type RolesType = (typeof Roles)[keyof typeof Roles];\n\ntype User = {\n  isAdmin: boolean;\n  name: string;\n  surname: string;\n  username: string;\n};\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  user = signal\u003cUser | null\u003e(null);\n\n  #router = inject(Router);\n\n  get role(): RolesType {\n    return this.user()?.isAdmin ? Roles.Admin : Roles.User;\n  }\n\n  get username(): string {\n    return this.user()?.username || '';\n  }\n\n  isAuth(): boolean {\n    return !!this.user();\n  }\n\n  isAuthGuard(): boolean {\n    const isAuth = this.isAuth();\n\n    if (isAuth) return true;\n\n    this.#router.navigate(['login']);\n    return false;\n  }\n\n  authAdmin() {\n    this.user.set({\n      isAdmin: true,\n      name: 'Giorgio',\n      surname: 'Galassi',\n      username: 'ggadmin',\n    });\n  }\n\n  authUser() {\n    this.user.set({\n      isAdmin: false,\n      name: 'Giorgio',\n      surname: 'Galassi',\n      username: 'gguser',\n    });\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리 서비스가 준비되었으니 routes.ts 내에서 라우트 리다이렉션을 사용자 정의하고 관리하는 방법을 살펴보겠습니다.\n\n```js\n// routes.ts\nimport { inject } from '@angular/core';\nimport { Routes } from '@angular/router';\n\nimport { AuthService, Roles, RolesType } from './providers/auth.service';\n\nimport { UserComponent } from './pages/user.component';\nimport { AdminComponent } from './pages/admin.component';\nimport { LoginComponent } from './pages/login.component';\n\nconst Routes = {\n  User: 'user',\n  Admin: 'admin',\n  Login: 'login',\n} as const;\n\nexport type RoutesType = (typeof Routes)[keyof typeof Routes];\n\nconst routesMap = new Map\u003cRolesType, RoutesType\u003e([\n  [Roles.Admin, Routes.Admin],\n  [Roles.User, Routes.User],\n]);\n\nexport const routes: Routes = [\n  {\n    path: '',\n    pathMatch: 'full',\n    redirectTo: () =\u003e {\n      const auth = inject(AuthService);\n      const { role } = auth;\n\n      if (!auth.isAuth()) return Routes.Login;\n      return routesMap.get(role) || Routes.User;\n    },\n  },\n  {\n    path: Routes.Login,\n    component: LoginComponent,\n  },\n  {\n    path: Routes.User,\n    component: UserComponent,\n    canActivate: [() =\u003e inject(AuthService).isAuthGuard()],\n  },\n  {\n    path: Routes.Admin,\n    component: AdminComponent,\n    canActivate: [() =\u003e inject(AuthService).isAuthGuard()],\n  },\n];\n```\n\n로그인되어 있는 사용자를 리디렉션할 위치를 선택하기 위해 AuthService를 인젝트하고 사용하는 redirectTo 함수에 초점을 맞추세요.\n\n사용자가 로그인되어 있지 않을 경우 로그인 페이지로 리디렉션하는 방법을 주목해 보세요. 또 하나 중요한 점은 일반 문자열이 아니라 특정 로직에서 검색한 문자열을 반환한다는 점입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이상으로 마치겠습니다!\n\n이 간단한 기사에서는 redirectTo 함수가 얼마나 유용하며 무엇을 할 수 있는지 살펴보았습니다.\n\n이것의 확장은 무한할 수 있습니다.\n\n여러분은 내부 상태를 활용하거나 서로 다른 서비스를 결합할 수도 있습니다. 좋은 실천이 한계입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에서 함께 놀 수 있는 StackBlitz가 있어요.\n\n지금까지 함께해줘서 고마워요. 모든 것이 지금까지 명확했기를 바래요. \n더 많은 글을 더 즐겁게 살펴볼 수 있다면 저는 기쁠 거예요.\n\n다음 글에서 봐요,\nG.","ogImage":{"url":"/assets/img/2024-07-01-Angularv18FunctionalRedirectionusingredirectTo_0.png"},"coverImage":"/assets/img/2024-07-01-Angularv18FunctionalRedirectionusingredirectTo_0.png","tag":["Tech"],"readingTime":5},{"title":"undefined","description":"","date":"2024-05-17 22:58","slug":"undefined","content":"\n\n영원이 너무 일찍 끝날 때\n\n결혼식 당일에 결혼이 끝나는 것을 목격한 적이 있나요? 이것은 제 이야기입니다. 결혼하기로 결정하기 전에, 배우자와 제게는 6년 동안 데이트한 시절이 있었습니다. 그 당시 그는 24세이고, 저는 20세였으므로 우리는 어린 커플이었습니다. 학교를 졸업한 후 돈을 벌러 다닐 때 흥미를 끄는 남자를 만났습니다. 같이 살기 전, 우리는 3개월 동안 데이트했습니다. 결혼식을 준비하기 시작한 후, 약 6년 동안의 데이트 끝에 결혼식을 계획하기 시작하면서 모든 것이 좋았습니다. 결혼을 한다고 발표했을 때, 동료들이 매우 행복해 했습니다. 제 남자친구는 결혼식 며칠 전부터 이상하게 행동하기 시작했고, 긴장된 것처럼 보였습니다. 일과 준비 때문에 피곤한 것만 언급하고 불편해 한 거지만, 저는 믿었습니다. 결혼식 당일, 그와 그의 부하들과 함께 와 주시리라 기대했는데, 결코 그런 적이 없었습니다. 전화를 받지 않아 바빠서 준비하고 있는 줄로 생각했습니다. 결혼식 당일 오후까지 전화를 받아서 결혼 준비를 하기에 못 미쳤다는 걸 설명한 후에 전화했습니다. 꿈일 거라고 믿었기에 울었습니다. 사람들이 떠나고, 위로해 주려는 나의 가족만 남아 있었습니다. 그것보다 더 빠른 이별을 본 적이 없습니다. 그는 다시 돌아오지 않았습니다.\n\n읽어 주셔서 감사합니다. 박수를 남기고 코멘트를 남겨주시는 것을 잊지 마세요!","ogImage":{"url":"/assets/img/undefined_0.png"},"coverImage":"/assets/img/undefined_0.png","tag":["Tech"],"readingTime":1}],"page":"1","totalPageCount":1,"totalPageGroupCount":1,"lastPageGroup":1,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"ZKJhj86Ua9Vhgqjyv7j_B","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>