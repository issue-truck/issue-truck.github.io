{"pageProps":{"post":{"title":"컴퓨터 공학 프로젝트를 진행하며 경험한 성공과 실패","description":"","date":"2024-05-16 20:57","slug":"2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject","content":"\n\n당신은 컴퓨터 공학 전공을 하시면서 프로젝트를 만들어 본 적이 있나요? 만약 그렇다면, 어떠한 경험을 하셨는지요? 확실히 즐거움, 흥분, 만족감과 함께 아픔과 후회가 섞인 흥미진진한 여정이었을 것입니다. 또한 가장 중요한 것은 그 황금 같은 '유레카 순간'이나 '전등이 켜지는 순간'일 겁니다. 제 이름은 만안 케르이고, 컴퓨터 공학 전공을 하는 소피모어 학생입니다. 최근 4학기 동안 첫 번째 완전한 프로젝트를 만들어볼 기회를 얻게 되었습니다. 제 여정을 여기서 공유하고, 프로젝트를 만들면서 얻은 실수와 성공을 강조하고 싶습니다.\n\n4학기가 시작된 지 몇 주 후, 학교에서 2학점을 가치 있는 미니 프로젝트를 진행해야 한다는 내용의 이메일을 받았습니다. 최대 3명의 팀원으로 구성된 그룹 프로젝트였습니다. 저는 친구인 아누쉬카와 아타르바 두 명과 함께 그룹을 이루었습니다. 우리 팀을 등록한 뒤 다음 단계는 혁신적이고 창의적으로 기술적 능력을 펼칠 수 있는 프로젝트 주제를 결정하는 것이었습니다. 아이디어를 떠올리는 과정에서 아타르바가 신선하고 고급스러운 제안을 하였습니다. 우리가 베이지안 검색 이론을 사용해 실용적인 목적으로, 예를 들어 물체를 물체를 찾는 것을 제안했습니다. 우리는 이 주제를 최종 결정하고 대양에서 비행기 추락 사고 현장을 찾는 특정 사용 사례를 선택하기로 했습니다. 우리가 이 프로젝트를 어떻게 실행할 것인지 대학 교직원에게 설명하자, 프로젝트의 멘토가 되겠다고 동의해 주셨습니다.\n\n우리는 베이지안 검색 이론에 대해 깊은 연구를 진행했고, 다양한 연구 논문과 기사를 찾아보았습니다. 우리는 비행 지점(LKP)을 기준으로 특정 검색 영역을 고려하고, 이 검색 영역을 격자로 나누는 기본 개념을 이해했습니다. 이러한 셀은 더 작은 검색 공간을 나타내며, 한 번에 한 칸씩 탐험하는 것이 아이디어입니다. 그런 다음, 비행 루트, 그의 LKP 및 지리 데이터와 같은 다양한 매개 변수를 사용하여 각 셀에 확률 값을 할당하여 그 셀에 추락 사고 현장이 존재할 가능성을 나타냅니다. 각 셀은 실제로 요구되는 물체가 존재할 확률을 나타내는 값과, 해당 셀에 존재한다면 해당 물체를 찾을 확률을 나타내는 값이 있습니다. 이전에 총체적인 확률과 베이즈 정리 같은 이론을 이해하는 것이 구현 전에 중요했습니다. '잃어버린 물체를 찾는 베이지안 접근'이라는 기사를 읽으며, 베이즈 정리가 검색이 진행됨에 따라 이러한 확률을 동적으로 업데이트하는 데 도움이 되며, 셀이 탐색됨에 따라 검색을 점점 더 최적화하는 데 도움이 된다는 것을 깨달았습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_1.png\" />\n\n이제 기본 개념을 잡았으니, 구현 작업에 착수했습니다. 우리 프로젝트의 핵심은 시뮬레이션인데, 이는 빨간색 탐색자가 확률 그리드를 탐색하고, 확률 값이 계속 업데이트되는 중에 최적의 탐색 경로를 따르는 것으로 구성될 것입니다. 이를 위해 게임 제작을 위한 모듈이 필요했습니다. 그래서 우리는 게임 제작을 위한 파이썬 모듈인 Pygame을 선택하기로 결정했습니다. Pygame을 사용하면 시뮬레이션을 쉽게 만들 수 있었습니다. 이 시뮬레이션을 보여줄 웹사이트를 만들기로 계획했고, 시뮬레이션이 표시되기 전에 사용자에게 관련 비행 정보를 입력해달라는 알림이 표시될 것입니다. 사용자가 이러한 세부 정보를 시각화하는 데 사용할 수 있는 웹사이트에 세계지도를 통합하여 전체 프로세스를 사용자 친화적으로 만들기로 결정했습니다. 그런 다음 모든 데이터가 시뮬레이션에 공급되어 확률 그리드를 만들고, 사용자는 시뮬레이션을 실행하여 탐색 프로세스를 시각화할 수 있을 것입니다.\n\n우리는 작업을 나누고 각자에게 할당된 작업에 착수했습니다. 회고를 통해, 우리는 맨 처음부터 프로젝트 계획을 세우고 자체적으로 마감일을 정해둘 것이었어야 했고, 이것은 생산성을 높여주었을 것입니다. 처음 몇 주간에는 목표를 설정하지 않아서 크게 진전할 수 없었습니다. 나중에 멘토가 이를 인지하고 우리에게 자체적으로 타임라인을 정하도록 강요했습니다. 마감 일정을 통해 가해진 추가 압박은 실제로 우리가 목표를 제 시간에 달성할 수 있도록 도왔습니다.\n\n아누샤는 웹사이트의 프론트엔드 개발을 담당했습니다. 웹사이트는 로그인 및 등록 기능이 있는 홈페이지에서 시작되며, 인증 후 사용자는 서비스 페이지로 리디렉션되어 비행의 출발지와 도착지 도시를 입력할 수 있습니다. 사용자는 비행의 마지막 알려진 위치(LKP)를 입력합니다. 이 페이지에는 LeafletJS를 사용하여 세계지도가 표시되며, 출발지 도시, 도착지 도시, 마커 및 비행 경로가 표시됩니다. 아누샤는 지도를 통합하고 마커 및 비행 경로를 정확하게 표시하는 데 어려움을 겪었습니다. 맵 통합에 대한 디버깅은 상당한 시간이 소요되었지만, 그녀의 인내심이 이를 이겨냈습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지 1](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_2.png)\n\n![이미지 2](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_3.png)\n\n![이미지 3](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_4.png)\n\n아따르바는 자동화 및 핵심 알고리즘에 초점을 맞췄어요. 해당 웹사이트는 Selenium을 사용하여 GEBCO 웹사이트에서 해양 깊이 데이터를 자동으로 다운로드합니다. 한편, 사용자는 회수된 시체나 파편의 좌표 및 회수 시간을 입력할 수 있는 페이지로 리디렉션됩니다. 제공된 경우, 알고리즘은 회수된 시체를 되추적하여 역 표류 궤적 경로 및 Scikit-learn의 비지도 기계 학습 모델인 Kernel Density Estimation을 사용한 분포를 그립니다. 아따르바는 Selenium을 다루는 데 어려움을 겪었는데, 특히 동적 콘텐츠 처리 및 안정적인 다운로드를 보장하는 데 어려움이 있었지만, 많은 테스트와 조정을 통해 이 문제를 해결했습니다. 또한, 회수된 시체를 되추적하는 알고리즘을 개발하는 것은 쉬운 작업이 아니었습니다. 우리는 해양 풍류와 바람의 속도와 방향을 제공하는 API를 찾아야 했습니다. 이 데이터를 획득한 후, 아따르바는 현재와 풍향 벡터의 속도를 사용하여 시체를 1시간 단위로 되추적하는 알고리즘을 작성하는 데 성공했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![image1](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_5.png)\n\n![image2](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_6.png)\n\n나(Manan)은 시뮬레이션 및 백엔드를 작업했어요. 파이게임을 사용하여 만든 시뮬레이션은 Pygbag를 사용하여 웹 브라우저에 임베드되어 있어요. 시뮬레이션은 먼저 네 가지 분포를 사용하여 만든 최종 확률 분포를 보여줘요:\n\n- LKP를 중심으로 하는 균일한 원형 분포.\n- 비행 경로를 따라서 정렬된 타원형 가우스 분포.\n- 역 이동 분포.\n- 대부분 업데이션 과정에 사용되는 해양 깊이 분포.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_7.png)\n\n시뮬레이션에서, 이 확률 분포 그리드를 표시한 후, 탐색자는 A* 탐색 알고리즘을 사용하여 최적의 탐색 경로를 따릅니다. 우리는 A* 탐색 알고리즘을 선택한 이유는 그 효율성과 최적 경로를 찾는 능력 때문입니다. 철저한 탐색 알고리즘과 달리, A*는 휴리스틱 함수를 기반으로 경로를 우선순위로 두어 탐색 시간과 계산 자원을 줄입니다. 해양류와 바람 패턴과 같은 도메인 특정 지식을 통합할 수 있는 능력이 성능과 실제 시나리오에 대한 적응성을 향상시킵니다. 그런 다음 베이즈 법칙을 사용하여 확률 값이 업데이트됩니다. 사용자는 좌표로 표시된 각 지점의 확률이 포함된 최적 경로를 담은 CSV 파일을 다운로드할 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_8.png)\n\n![이미지](/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_9.png)\n\n<div class=\"content-ad\"></div>\n\n시뮬레이션을 개발하는 것은 여러 확률 분포를 통합하고 검색 과정 중 정확한 업데이트를 보장해야 했기 때문에 어려웠습니다. A* 검색 알고리즘을 구현하고 베이지안 업데이트와 통합하기 위해서는 신중한 조정과 디버깅이 필요했습니다.\n\n또한, 저는 백엔드를 담당했기 때문에 팀원들의 진행 상황을 모니터링하고 모든 기능을 주요 제품에 통합하는 것을 확실히 제공했습니다. 백엔드 개발을 위해 Django를 사용하기로 결정했는데, 이는 저의 폭넓은 경험 때문입니다. 제 지식에도 불구하고, 모든 것을 통합하는 동안 맞닥뜨린 많은 장애물이 있었습니다. 하지만 이 프로젝트에 대해 정말 열정적으로 생각했고, 그것이 저를 포기하지 않게 동기부여했습니다. 항상 새로운 것을 배우기 위해 준비가 되어 있었고, 학습에 관심을 가지는 이 유일한 태도가 저에게 경계를 넓히게 하고 이 프로젝트를 완벽하게 만들기 위해 최선을 다하는 것을 허용했습니다.\n\n도전과 배운점:\n\n- 여러 기술 통합:\n\n<div class=\"content-ad\"></div>\n\nDjango, Pygame, LeafletJS, Selenium, 그리고 Scikit-learn 같은 기술들을 사용하여 하나의 완성품으로 결합하는 것은 가장 어려운 도전이었습니다. 각 도구마다 학습 곡선과 통합 문제가 있었습니다. 예를 들어, Pygame 시뮬레이션을 Pygbag를 사용하여 웹 브라우저에 임베딩하는 것은 상당한 시간과 실험이 필요했습니다.\n\n- 알고리즘 복잡성:\n\n베이지안 검색 이론과 A* 검색 알고리즘을 이해하고 구현하는 것은 지적으로 요구되는 작업이었습니다. 우리는 수 많은 시간을 연구 논문을 읽고 우리의 구현을 문제해결하는 데 쓰게 되었습니다.\n\n- 사용자 경험:\n\n<div class=\"content-ad\"></div>\n\n원활하고 사용자 친화적인 경험을 보장하는 것이 중요했습니다. Anushka의 노력으로 직관적인 인터페이스를 만들고 지도 시각화를 다룬 것이 이 프로젝트를 접근 가능하게 하는 데 핵심적이었습니다.\n\n- 데이터 처리와 자동화:\n\nSelenium을 사용하여 GEBCO 웹사이트에서 데이터 다운로드를 자동화하고 동적 콘텐츠를 다루는 것은 상당한 어려움을 가졌습니다. Atharva의 문제 해결에 대한 끈질김이 칭찬받을 만했습니다.\n\n마지막으로, 이 프로젝트를 완료하는 것은 감정의 롤러코스터이자 환상적인 학습 경험이었습니다. 복잡한 이론을 이해하고 기능적인 시뮬레이션을 구현하는 데 많은 도전을 겪었지만 소중한 지식과 기술을 얻게 되었습니다. 토마스 에디슨이 유명하게 말한 대로, \"실패한 것이 아니다. 제대로 동작하지 않는 1만가지 방법을 찾아낸 것일 뿐\"입니다. 동기부여를 받는 동기를 가진 학생들에게 요구되는 조언은 여러분의 프로젝트에서 높낮이를 진심으로 받아들이는 것입니다. 각각의 단계가 새로운 것을 가르켜주는 것을 기억하세요. 기억하세요, 모든 실수는 성공으로 가는 발판입니다.\n\n<div class=\"content-ad\"></div>\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_0.png"},"coverImage":"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"당신은 컴퓨터 공학 전공을 하시면서 프로젝트를 만들어 본 적이 있나요? 만약 그렇다면, 어떠한 경험을 하셨는지요? 확실히 즐거움, 흥분, 만족감과 함께 아픔과 후회가 섞인 흥미진진한 여정이었을 것입니다. 또한 가장 중요한 것은 그 황금 같은 '유레카 순간'이나 '전등이 켜지는 순간'일 겁니다. 제 이름은 만안 케르이고, 컴퓨터 공학 전공을 하는 소피모어 학생입니다. 최근 4학기 동안 첫 번째 완전한 프로젝트를 만들어볼 기회를 얻게 되었습니다. 제 여정을 여기서 공유하고, 프로젝트를 만들면서 얻은 실수와 성공을 강조하고 싶습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"4학기가 시작된 지 몇 주 후, 학교에서 2학점을 가치 있는 미니 프로젝트를 진행해야 한다는 내용의 이메일을 받았습니다. 최대 3명의 팀원으로 구성된 그룹 프로젝트였습니다. 저는 친구인 아누쉬카와 아타르바 두 명과 함께 그룹을 이루었습니다. 우리 팀을 등록한 뒤 다음 단계는 혁신적이고 창의적으로 기술적 능력을 펼칠 수 있는 프로젝트 주제를 결정하는 것이었습니다. 아이디어를 떠올리는 과정에서 아타르바가 신선하고 고급스러운 제안을 하였습니다. 우리가 베이지안 검색 이론을 사용해 실용적인 목적으로, 예를 들어 물체를 물체를 찾는 것을 제안했습니다. 우리는 이 주제를 최종 결정하고 대양에서 비행기 추락 사고 현장을 찾는 특정 사용 사례를 선택하기로 했습니다. 우리가 이 프로젝트를 어떻게 실행할 것인지 대학 교직원에게 설명하자, 프로젝트의 멘토가 되겠다고 동의해 주셨습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 베이지안 검색 이론에 대해 깊은 연구를 진행했고, 다양한 연구 논문과 기사를 찾아보았습니다. 우리는 비행 지점(LKP)을 기준으로 특정 검색 영역을 고려하고, 이 검색 영역을 격자로 나누는 기본 개념을 이해했습니다. 이러한 셀은 더 작은 검색 공간을 나타내며, 한 번에 한 칸씩 탐험하는 것이 아이디어입니다. 그런 다음, 비행 루트, 그의 LKP 및 지리 데이터와 같은 다양한 매개 변수를 사용하여 각 셀에 확률 값을 할당하여 그 셀에 추락 사고 현장이 존재할 가능성을 나타냅니다. 각 셀은 실제로 요구되는 물체가 존재할 확률을 나타내는 값과, 해당 셀에 존재한다면 해당 물체를 찾을 확률을 나타내는 값이 있습니다. 이전에 총체적인 확률과 베이즈 정리 같은 이론을 이해하는 것이 구현 전에 중요했습니다. '잃어버린 물체를 찾는 베이지안 접근'이라는 기사를 읽으며, 베이즈 정리가 검색이 진행됨에 따라 이러한 확률을 동적으로 업데이트하는 데 도움이 되며, 셀이 탐색됨에 따라 검색을 점점 더 최적화하는 데 도움이 된다는 것을 깨달았습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 기본 개념을 잡았으니, 구현 작업에 착수했습니다. 우리 프로젝트의 핵심은 시뮬레이션인데, 이는 빨간색 탐색자가 확률 그리드를 탐색하고, 확률 값이 계속 업데이트되는 중에 최적의 탐색 경로를 따르는 것으로 구성될 것입니다. 이를 위해 게임 제작을 위한 모듈이 필요했습니다. 그래서 우리는 게임 제작을 위한 파이썬 모듈인 Pygame을 선택하기로 결정했습니다. Pygame을 사용하면 시뮬레이션을 쉽게 만들 수 있었습니다. 이 시뮬레이션을 보여줄 웹사이트를 만들기로 계획했고, 시뮬레이션이 표시되기 전에 사용자에게 관련 비행 정보를 입력해달라는 알림이 표시될 것입니다. 사용자가 이러한 세부 정보를 시각화하는 데 사용할 수 있는 웹사이트에 세계지도를 통합하여 전체 프로세스를 사용자 친화적으로 만들기로 결정했습니다. 그런 다음 모든 데이터가 시뮬레이션에 공급되어 확률 그리드를 만들고, 사용자는 시뮬레이션을 실행하여 탐색 프로세스를 시각화할 수 있을 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 작업을 나누고 각자에게 할당된 작업에 착수했습니다. 회고를 통해, 우리는 맨 처음부터 프로젝트 계획을 세우고 자체적으로 마감일을 정해둘 것이었어야 했고, 이것은 생산성을 높여주었을 것입니다. 처음 몇 주간에는 목표를 설정하지 않아서 크게 진전할 수 없었습니다. 나중에 멘토가 이를 인지하고 우리에게 자체적으로 타임라인을 정하도록 강요했습니다. 마감 일정을 통해 가해진 추가 압박은 실제로 우리가 목표를 제 시간에 달성할 수 있도록 도왔습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아누샤는 웹사이트의 프론트엔드 개발을 담당했습니다. 웹사이트는 로그인 및 등록 기능이 있는 홈페이지에서 시작되며, 인증 후 사용자는 서비스 페이지로 리디렉션되어 비행의 출발지와 도착지 도시를 입력할 수 있습니다. 사용자는 비행의 마지막 알려진 위치(LKP)를 입력합니다. 이 페이지에는 LeafletJS를 사용하여 세계지도가 표시되며, 출발지 도시, 도착지 도시, 마커 및 비행 경로가 표시됩니다. 아누샤는 지도를 통합하고 마커 및 비행 경로를 정확하게 표시하는 데 어려움을 겪었습니다. 맵 통합에 대한 디버깅은 상당한 시간이 소요되었지만, 그녀의 인내심이 이를 이겨냈습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_2.png\",\n        alt: \"이미지 1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_3.png\",\n        alt: \"이미지 2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_4.png\",\n        alt: \"이미지 3\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아따르바는 자동화 및 핵심 알고리즘에 초점을 맞췄어요. 해당 웹사이트는 Selenium을 사용하여 GEBCO 웹사이트에서 해양 깊이 데이터를 자동으로 다운로드합니다. 한편, 사용자는 회수된 시체나 파편의 좌표 및 회수 시간을 입력할 수 있는 페이지로 리디렉션됩니다. 제공된 경우, 알고리즘은 회수된 시체를 되추적하여 역 표류 궤적 경로 및 Scikit-learn의 비지도 기계 학습 모델인 Kernel Density Estimation을 사용한 분포를 그립니다. 아따르바는 Selenium을 다루는 데 어려움을 겪었는데, 특히 동적 콘텐츠 처리 및 안정적인 다운로드를 보장하는 데 어려움이 있었지만, 많은 테스트와 조정을 통해 이 문제를 해결했습니다. 또한, 회수된 시체를 되추적하는 알고리즘을 개발하는 것은 쉬운 작업이 아니었습니다. 우리는 해양 풍류와 바람의 속도와 방향을 제공하는 API를 찾아야 했습니다. 이 데이터를 획득한 후, 아따르바는 현재와 풍향 벡터의 속도를 사용하여 시체를 1시간 단위로 되추적하는 알고리즘을 작성하는 데 성공했습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_5.png\",\n        alt: \"image1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_6.png\",\n        alt: \"image2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"나(Manan)은 시뮬레이션 및 백엔드를 작업했어요. 파이게임을 사용하여 만든 시뮬레이션은 Pygbag를 사용하여 웹 브라우저에 임베드되어 있어요. 시뮬레이션은 먼저 네 가지 분포를 사용하여 만든 최종 확률 분포를 보여줘요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"LKP를 중심으로 하는 균일한 원형 분포.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"비행 경로를 따라서 정렬된 타원형 가우스 분포.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"역 이동 분포.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"대부분 업데이션 과정에 사용되는 해양 깊이 분포.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_7.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시뮬레이션에서, 이 확률 분포 그리드를 표시한 후, 탐색자는 A* 탐색 알고리즘을 사용하여 최적의 탐색 경로를 따릅니다. 우리는 A* 탐색 알고리즘을 선택한 이유는 그 효율성과 최적 경로를 찾는 능력 때문입니다. 철저한 탐색 알고리즘과 달리, A*는 휴리스틱 함수를 기반으로 경로를 우선순위로 두어 탐색 시간과 계산 자원을 줄입니다. 해양류와 바람 패턴과 같은 도메인 특정 지식을 통합할 수 있는 능력이 성능과 실제 시나리오에 대한 적응성을 향상시킵니다. 그런 다음 베이즈 법칙을 사용하여 확률 값이 업데이트됩니다. 사용자는 좌표로 표시된 각 지점의 확률이 포함된 최적 경로를 담은 CSV 파일을 다운로드할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_8.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-TheHighsandLowsofBuildingaComputerEngineeringProject_9.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시뮬레이션을 개발하는 것은 여러 확률 분포를 통합하고 검색 과정 중 정확한 업데이트를 보장해야 했기 때문에 어려웠습니다. A* 검색 알고리즘을 구현하고 베이지안 업데이트와 통합하기 위해서는 신중한 조정과 디버깅이 필요했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한, 저는 백엔드를 담당했기 때문에 팀원들의 진행 상황을 모니터링하고 모든 기능을 주요 제품에 통합하는 것을 확실히 제공했습니다. 백엔드 개발을 위해 Django를 사용하기로 결정했는데, 이는 저의 폭넓은 경험 때문입니다. 제 지식에도 불구하고, 모든 것을 통합하는 동안 맞닥뜨린 많은 장애물이 있었습니다. 하지만 이 프로젝트에 대해 정말 열정적으로 생각했고, 그것이 저를 포기하지 않게 동기부여했습니다. 항상 새로운 것을 배우기 위해 준비가 되어 있었고, 학습에 관심을 가지는 이 유일한 태도가 저에게 경계를 넓히게 하고 이 프로젝트를 완벽하게 만들기 위해 최선을 다하는 것을 허용했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"도전과 배운점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"여러 기술 통합:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Django, Pygame, LeafletJS, Selenium, 그리고 Scikit-learn 같은 기술들을 사용하여 하나의 완성품으로 결합하는 것은 가장 어려운 도전이었습니다. 각 도구마다 학습 곡선과 통합 문제가 있었습니다. 예를 들어, Pygame 시뮬레이션을 Pygbag를 사용하여 웹 브라우저에 임베딩하는 것은 상당한 시간과 실험이 필요했습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"알고리즘 복잡성:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"베이지안 검색 이론과 A* 검색 알고리즘을 이해하고 구현하는 것은 지적으로 요구되는 작업이었습니다. 우리는 수 많은 시간을 연구 논문을 읽고 우리의 구현을 문제해결하는 데 쓰게 되었습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"사용자 경험:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원활하고 사용자 친화적인 경험을 보장하는 것이 중요했습니다. Anushka의 노력으로 직관적인 인터페이스를 만들고 지도 시각화를 다룬 것이 이 프로젝트를 접근 가능하게 하는 데 핵심적이었습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"데이터 처리와 자동화:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Selenium을 사용하여 GEBCO 웹사이트에서 데이터 다운로드를 자동화하고 동적 콘텐츠를 다루는 것은 상당한 어려움을 가졌습니다. Atharva의 문제 해결에 대한 끈질김이 칭찬받을 만했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 이 프로젝트를 완료하는 것은 감정의 롤러코스터이자 환상적인 학습 경험이었습니다. 복잡한 이론을 이해하고 기능적인 시뮬레이션을 구현하는 데 많은 도전을 겪었지만 소중한 지식과 기술을 얻게 되었습니다. 토마스 에디슨이 유명하게 말한 대로, \\\"실패한 것이 아니다. 제대로 동작하지 않는 1만가지 방법을 찾아낸 것일 뿐\\\"입니다. 동기부여를 받는 동기를 가진 학생들에게 요구되는 조언은 여러분의 프로젝트에서 높낮이를 진심으로 받아들이는 것입니다. 각각의 단계가 새로운 것을 가르켜주는 것을 기억하세요. 기억하세요, 모든 실수는 성공으로 가는 발판입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"즐거운 코딩하세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}