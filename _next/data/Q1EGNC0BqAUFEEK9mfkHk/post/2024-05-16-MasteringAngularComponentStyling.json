{"pageProps":{"post":{"title":"앵귤러 컴포넌트 스타일링 마스터하기","description":"","date":"2024-05-16 00:26","slug":"2024-05-16-MasteringAngularComponentStyling","content":"\n\n\n<img src=\"/assets/img/2024-05-16-MasteringAngularComponentStyling_0.png\" />\n\n이 블로그 포스트에서는 Angular의 Shadow DOM 모드 및 Emulated 모드, 스타일 스코프, 템플릿에서 스타일 정의, 외부 스타일 파일 참조 및 의사 클래스에 대해 알아볼 것입니다. 각 개념에 대한 예제 코드도 제공할 것입니다.\n\n# 컴포넌트 스타일링\n\n컴포넌트는 컴포넌트의 DOM에 적용되는 CSS 스타일을 포함할 수 있습니다. 이러한 스타일은 @Component 데코레이터의 styles 속성을 사용하여 인라인으로 정의하거나 styleUrl 속성을 사용하여 별도의 파일에서 정의할 수 있습니다.\n\n\n\n\n# 스타일 스코핑\n\n각 컴포넌트마다 뷰 캡슐화 설정이 있어서 프레임워크가 컴포넌트의 스타일을 적용하는 방식을 결정합니다. 세 가지 뷰 캡슐화 모드가 있습니다: 모의, 쉐도우 돔, 그리고 없음.\n\n## 모의:\n\n- 모의 모드는 Angular 컴포넌트의 기본 모드로, 컴포넌트의 스타일은 해당 컴포넌트의 템플릿에서 정의된 요소에만 적용됩니다. Angular는 각 컴포넌트 인스턴스마다 고유한 HTML 속성을 생성하고 해당 컴포넌트의 템플릿 요소에 추가합니다. 이로써 컴포넌트의 스타일이 애플리케이션의 다른 부분에 영향을 미치지 않습니다.\n- 다음은 모의 모드로 지정된 컴포넌트의 예시입니다:\n\n\n\n```js\n@Component({\n  selector: 'app-example',\n  template: `\n    <h1>This is an example component</h1>\n    <p>This paragraph will be styled</p>\n  `,\n  styles: [`\n    p {\n      color: red;\n    }\n  `]\n})\nexport class ExampleComponent { }\n```\n\n- 이 예시에서 p 태그는 빨간색 텍스트로 스타일이 지정됩니다. 그러나 이 스타일은 이 컴포넌트 바깥의 다른 p 태그에는 영향을 주지 않습니다.\n\n## Shadow DOM:\n\n- Shadow DOM 모드는 스타일을 컴포넌트 뷰에 지정하는 데 네이티브 Shadow DOM API를 사용합니다. 이렇게 함으로써 스타일이 더 잘 격리되어 컴포넌트별 스타일을 쉽게 작성할 수 있습니다. 그러나 이 모드는 Shadow DOM API를 지원하는 현대적인 브라우저가 필요합니다.\n- 엄격히 말해서, 컴포넌트의 스타일만 컴포넌트 템플릿 내의 요소에 적용됨을 보장합니다.\n- Shadow DOM 모드를 사용한 예시는 다음과 같습니다:```\n\n\n\n```js\n@Component({\n  selector: 'app-example',\n  template: `\n    <h1>이것은 예제 컴포넌트입니다</h1>\n    <p>이 단락은 스타일이 적용될 것입니다</p>\n  `,\n  styleUrls: ['./example.component.shadow.css'],\n  encapsulation: ViewEncapsulation.ShadowDom\n})\nexport class ExampleComponent { }\n```\n\n- 이 예제에서 styleUrls 속성은 이 컴포넌트의 스타일을 포함하는 별도의 CSS 파일을 가리킵니다. 캡슐화 속성은 ViewEncapsulation.ShadowDom으로 설정되어 Shadow DOM 모드를 활성화합니다.\n\n## None:\n\n- None 모드에서 Angular는 컴포넌트의 모든 스타일 캡슐화를 비활성화하여 스타일이 다른 부분에 영향을 줄 수 있는 전역 스타일로 동작합니다.\n- None 모드를 사용하는 컴포넌트의 예시는 다음과 같습니다:```\n\n\n\n```js\n@Component({\n  selector: 'app-example',\n  template: `\n    <h1>This is an example component</h1>\n    <p>This paragraph will be styled</p>\n  `,\n  styles: [`\n    p {\n      color: red;\n    }\n  `],\n  encapsulation: ViewEncapsulation.None\n})\nexport class ExampleComponent { }\n```\n\n- 위 예제에서는 view 캡슐화를 비활성화하기 위해 encapsulation 속성이 ViewEncapsulation.None으로 설정되어 있습니다. 이는 p 태그를 빨간색 텍스트로 스타일링하지만, 이 스타일이 이 컴포넌트 외부의 다른 p 태그에도 영향을 미칠 수 있음을 의미합니다.\n\n# 템플릿에서 스타일 정의하기\n\n컴포넌트 템플릿에서 `style` 요소를 사용하여 추가 스타일을 정의할 수 있습니다. 이 방법으로 정의된 스타일에는 컴포넌트의 view 캡슐화 모드가 적용됩니다.\n\n\n\n\n# 외부 스타일 파일 참조\n\n컴포넌트 템플릿은 `link` 요소를 사용하여 CSS 파일을 참조할 수 있습니다. 또한 CSS는 @import at-rule을 사용할 수 있습니다.\n\n# 가상 클래스\n\nAngular의 emulated 캡슐화 모드는 :host와 :host-context() 가상 클래스를 지원하며, 사용자 정의 가상 클래스 ::ng-deep도 지원합니다. 그러나 Angular 팀은 ::ng-deep의 신규 사용을 강력히 권장하지 않습니다.\n\n\n\n# Shadow DOM Mode vs Emulated Mode\n\n앵귤러에서는 Shadow DOM 모드와 Emulated 모드가 컴포넌트 스타일을 적용하는 두 가지 다른 방식입니다. 아래는 두 모드를 비교한 내용입니다:\n\n## Emulated Mode\n\n- 기본 모드: 이것은 앵귤러의 기본 뷰 캡슐화 모드입니다.\n- 속성 기반 스코프: 앵귤러는 각 컴포넌트 인스턴스에 대해 고유한 HTML 속성을 생성하고 컴포넌트 템플릿의 요소에 추가합니다. 이 속성은 스타일을 적용하는 데 사용됩니다.\n- 네이티브 Shadow DOM 없음: Emulated 모드는 네이티브 Shadow DOM API를 사용하지 않습니다.\n- 브라우저 지원: 이 모드는 구식 브라우저를 포함한 모든 브라우저에서 작동합니다.\n- 성능: Shadow DOM 모드보다 빠릅니다. 왜냐하면 브라우저가 Shadow DOM을 생성할 필요가 없기 때문입니다.\n- 스타일 제한: :host와 같은 일부 CSS 선택기가 예상대로 작동하지 않을 수 있습니다.\n\n\n\n## 셰도우 DOM 모드\n\n- 네이티브 셰도우 DOM: 이 모드는 원본 셰도우 DOM API를 사용하여 스타일을 정확하게 스코핑합니다.\n- 네이티브 스코핑: 스타일은 컴포넌트의 셰도우 DOM 내에서 스코핑되어 해당 컴포넌트 내 요소에만 적용됩니다.\n- 더 나은 스타일 격리: 스타일을 더 잘 격리시켜 컴포넌트별 스타일 작성이 쉬워집니다.\n- 브라우저 지원: Chrome, Firefox, Edge와 같은 새로운 브라우저를 지원합니다.\n- 성능: Emulated 모드보다 느릴 수 있으며, 브라우저가 셰도우 DOM을 생성해야 합니다.\n- 스타일 제한: :host와 같은 고급 CSS 선택자를 지원하며 CSS 가상 요소에 대한 더 나은 지원을 제공합니다.\n\n<img src=\"/assets/img/2024-05-16-MasteringAngularComponentStyling_1.png\" />\n\nAngular 가이드의 컴포넌트 스타일링에 대한 모든 주제를 다루었기를 바라며!","ogImage":{"url":"/assets/img/2024-05-16-MasteringAngularComponentStyling_0.png"},"coverImage":"/assets/img/2024-05-16-MasteringAngularComponentStyling_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이 블로그 포스트에서는 Angular의 Shadow DOM 모드 및 Emulated 모드, 스타일 스코프, 템플릿에서 스타일 정의, 외부 스타일 파일 참조 및 의사 클래스에 대해 알아볼 것입니다. 각 개념에 대한 예제 코드도 제공할 것입니다.</p>\n<h1>컴포넌트 스타일링</h1>\n<p>컴포넌트는 컴포넌트의 DOM에 적용되는 CSS 스타일을 포함할 수 있습니다. 이러한 스타일은 @Component 데코레이터의 styles 속성을 사용하여 인라인으로 정의하거나 styleUrl 속성을 사용하여 별도의 파일에서 정의할 수 있습니다.</p>\n<h1>스타일 스코핑</h1>\n<p>각 컴포넌트마다 뷰 캡슐화 설정이 있어서 프레임워크가 컴포넌트의 스타일을 적용하는 방식을 결정합니다. 세 가지 뷰 캡슐화 모드가 있습니다: 모의, 쉐도우 돔, 그리고 없음.</p>\n<h2>모의:</h2>\n<ul>\n<li>모의 모드는 Angular 컴포넌트의 기본 모드로, 컴포넌트의 스타일은 해당 컴포넌트의 템플릿에서 정의된 요소에만 적용됩니다. Angular는 각 컴포넌트 인스턴스마다 고유한 HTML 속성을 생성하고 해당 컴포넌트의 템플릿 요소에 추가합니다. 이로써 컴포넌트의 스타일이 애플리케이션의 다른 부분에 영향을 미치지 않습니다.</li>\n<li>다음은 모의 모드로 지정된 컴포넌트의 예시입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-example'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;h1>This is an example component&#x3C;/h1>\n    &#x3C;p>This paragraph will be styled&#x3C;/p>\n  `</span>,\n  <span class=\"hljs-attr\">styles</span>: [<span class=\"hljs-string\">`\n    p {\n      color: red;\n    }\n  `</span>]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExampleComponent</span> { }\n</code></pre>\n<ul>\n<li>이 예시에서 p 태그는 빨간색 텍스트로 스타일이 지정됩니다. 그러나 이 스타일은 이 컴포넌트 바깥의 다른 p 태그에는 영향을 주지 않습니다.</li>\n</ul>\n<h2>Shadow DOM:</h2>\n<ul>\n<li>Shadow DOM 모드는 스타일을 컴포넌트 뷰에 지정하는 데 네이티브 Shadow DOM API를 사용합니다. 이렇게 함으로써 스타일이 더 잘 격리되어 컴포넌트별 스타일을 쉽게 작성할 수 있습니다. 그러나 이 모드는 Shadow DOM API를 지원하는 현대적인 브라우저가 필요합니다.</li>\n<li>엄격히 말해서, 컴포넌트의 스타일만 컴포넌트 템플릿 내의 요소에 적용됨을 보장합니다.</li>\n<li>Shadow DOM 모드를 사용한 예시는 다음과 같습니다:```</li>\n</ul>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-example'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;h1>이것은 예제 컴포넌트입니다&#x3C;/h1>\n    &#x3C;p>이 단락은 스타일이 적용될 것입니다&#x3C;/p>\n  `</span>,\n  <span class=\"hljs-attr\">styleUrls</span>: [<span class=\"hljs-string\">'./example.component.shadow.css'</span>],\n  <span class=\"hljs-attr\">encapsulation</span>: <span class=\"hljs-title class_\">ViewEncapsulation</span>.<span class=\"hljs-property\">ShadowDom</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExampleComponent</span> { }\n</code></pre>\n<ul>\n<li>이 예제에서 styleUrls 속성은 이 컴포넌트의 스타일을 포함하는 별도의 CSS 파일을 가리킵니다. 캡슐화 속성은 ViewEncapsulation.ShadowDom으로 설정되어 Shadow DOM 모드를 활성화합니다.</li>\n</ul>\n<h2>None:</h2>\n<ul>\n<li>None 모드에서 Angular는 컴포넌트의 모든 스타일 캡슐화를 비활성화하여 스타일이 다른 부분에 영향을 줄 수 있는 전역 스타일로 동작합니다.</li>\n<li>None 모드를 사용하는 컴포넌트의 예시는 다음과 같습니다:```</li>\n</ul>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-example'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;h1>This is an example component&#x3C;/h1>\n    &#x3C;p>This paragraph will be styled&#x3C;/p>\n  `</span>,\n  <span class=\"hljs-attr\">styles</span>: [<span class=\"hljs-string\">`\n    p {\n      color: red;\n    }\n  `</span>],\n  <span class=\"hljs-attr\">encapsulation</span>: <span class=\"hljs-title class_\">ViewEncapsulation</span>.<span class=\"hljs-property\">None</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExampleComponent</span> { }\n</code></pre>\n<ul>\n<li>위 예제에서는 view 캡슐화를 비활성화하기 위해 encapsulation 속성이 ViewEncapsulation.None으로 설정되어 있습니다. 이는 p 태그를 빨간색 텍스트로 스타일링하지만, 이 스타일이 이 컴포넌트 외부의 다른 p 태그에도 영향을 미칠 수 있음을 의미합니다.</li>\n</ul>\n<h1>템플릿에서 스타일 정의하기</h1>\n<p>컴포넌트 템플릿에서 <code>style</code> 요소를 사용하여 추가 스타일을 정의할 수 있습니다. 이 방법으로 정의된 스타일에는 컴포넌트의 view 캡슐화 모드가 적용됩니다.</p>\n<h1>외부 스타일 파일 참조</h1>\n<p>컴포넌트 템플릿은 <code>link</code> 요소를 사용하여 CSS 파일을 참조할 수 있습니다. 또한 CSS는 @import at-rule을 사용할 수 있습니다.</p>\n<h1>가상 클래스</h1>\n<p>Angular의 emulated 캡슐화 모드는 :host와 :host-context() 가상 클래스를 지원하며, 사용자 정의 가상 클래스 ::ng-deep도 지원합니다. 그러나 Angular 팀은 ::ng-deep의 신규 사용을 강력히 권장하지 않습니다.</p>\n<h1>Shadow DOM Mode vs Emulated Mode</h1>\n<p>앵귤러에서는 Shadow DOM 모드와 Emulated 모드가 컴포넌트 스타일을 적용하는 두 가지 다른 방식입니다. 아래는 두 모드를 비교한 내용입니다:</p>\n<h2>Emulated Mode</h2>\n<ul>\n<li>기본 모드: 이것은 앵귤러의 기본 뷰 캡슐화 모드입니다.</li>\n<li>속성 기반 스코프: 앵귤러는 각 컴포넌트 인스턴스에 대해 고유한 HTML 속성을 생성하고 컴포넌트 템플릿의 요소에 추가합니다. 이 속성은 스타일을 적용하는 데 사용됩니다.</li>\n<li>네이티브 Shadow DOM 없음: Emulated 모드는 네이티브 Shadow DOM API를 사용하지 않습니다.</li>\n<li>브라우저 지원: 이 모드는 구식 브라우저를 포함한 모든 브라우저에서 작동합니다.</li>\n<li>성능: Shadow DOM 모드보다 빠릅니다. 왜냐하면 브라우저가 Shadow DOM을 생성할 필요가 없기 때문입니다.</li>\n<li>스타일 제한: :host와 같은 일부 CSS 선택기가 예상대로 작동하지 않을 수 있습니다.</li>\n</ul>\n<h2>셰도우 DOM 모드</h2>\n<ul>\n<li>네이티브 셰도우 DOM: 이 모드는 원본 셰도우 DOM API를 사용하여 스타일을 정확하게 스코핑합니다.</li>\n<li>네이티브 스코핑: 스타일은 컴포넌트의 셰도우 DOM 내에서 스코핑되어 해당 컴포넌트 내 요소에만 적용됩니다.</li>\n<li>더 나은 스타일 격리: 스타일을 더 잘 격리시켜 컴포넌트별 스타일 작성이 쉬워집니다.</li>\n<li>브라우저 지원: Chrome, Firefox, Edge와 같은 새로운 브라우저를 지원합니다.</li>\n<li>성능: Emulated 모드보다 느릴 수 있으며, 브라우저가 셰도우 DOM을 생성해야 합니다.</li>\n<li>스타일 제한: :host와 같은 고급 CSS 선택자를 지원하며 CSS 가상 요소에 대한 더 나은 지원을 제공합니다.</li>\n</ul>\n<p>Angular 가이드의 컴포넌트 스타일링에 대한 모든 주제를 다루었기를 바라며!</p>\n</body>\n</html>\n"},"__N_SSG":true}