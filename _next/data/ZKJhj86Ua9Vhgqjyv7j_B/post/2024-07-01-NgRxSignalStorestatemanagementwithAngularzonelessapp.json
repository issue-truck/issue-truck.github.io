{"pageProps":{"post":{"title":"Zoneless Angular 앱에서 NgRx SignalStore 상태 관리 방법","description":"","date":"2024-07-01 20:39","slug":"2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp","content":"\n\n![2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png](/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png)\n\n여러분은 이미 새로운 Angular 도구인 Signals에 대해 알고 있을 것입니다. 내 의견으로는, 이는 매우 강력하고 편리한 도구로, 컨트롤러의 코드 양을 줄이고 개발 과정을 더 빠르게 만들어줍니다. 동시에, NgRx가 제안하는 상태 관리를 위한 또 다른 도구에 대해 이야기해보고 싶습니다. 이 방식을 사용하면 뷰 컨트롤러에 코드가 적어지며 페이지 효율성이 높아지고, 컨트롤러에서 부작용을 처리할 필요가 없으며 zoneless입니다. 또한 상태 관리가 만병통치약이 아니라는 것을 기억해야 하며, 필요한 프로젝트에서만 사용해야 합니다. 그렇지 않으면 페이지/프로젝트에 복잡성만 더할 수 있습니다.\n\n# 사례 설명\n\n서버에서 가져온 책 목록이 있는 상황을 상상해보겠습니다. 이들을 상태로 유지하고, 제거하거나 책을 추가할 수 있는 페이지에 표시하는 작업을 수행해야 합니다(NgRx 문서에서 가져온 케이스입니다).\n\n<div class=\"content-ad\"></div>\n\n우리가 할 수 있는 일은 무엇일까요? 우리는 모든 복잡성을 갖춘 NgRx 스토어를 사용할 수 있고, ngneat/elf store와 같은 더 간단한 솔루션을 사용할 수도 있어요. 이러한 기술을 사용하면 여전히 데이터 스트림(옵저버블)과 zone.js와 함께 작업할 것이지만, Angular의 마지막 18번째 버전은 zoneless change detection 접근 방식을 제안하고 있어요. 네, 현재는 실험적인 부분이라고 할 수 있지만, Ivy의 경우를 상기해보세요. Angular 8에서는 선택 사항이었지만, Angular 9에서는 표준이 되었고 View Engine을 사용하려면 다시 거슬러 올라가야 했어요. 그래서, 지금부터는 이 공개된(NgRx 팀이 발표한) 새로운 도구를 사용해 보려고 해요 (이 글을 작성하는 시점에는 RC 상태에요). 이제부터는 더 많은 코드와 간결한 설명으로 진행할게요 :)\n\n이 글에서 설명된 방법은 NgRx SignalStore 문서에서 영감을 받았어요.\n\n# 가짜 DataService 구현\n\n서버에서 책 목록을 반환, 추가, 삭제하는 DataService가 있어요. 우리의 경우에는 서버 요청 수명을 흉내내기 위해 하드 코딩된 책 목록과 지연된 응답이 있는 서비스가 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport {Injectable} from \"@angular/core\";\nimport {delay, map, Observable, of} from \"rxjs\";\nimport {IBook} from \"../interfaces/book.interface\";\n\nexport interface IBook {\n    id: number,\n    name: string,\n    pageCount: number\n}\n\n@Injectable({providedIn: \"root\"})\nexport class DataService {\n\n    private books: IBook[] = [\n        {\n            id: 0,\n            name: 'Book 0',\n            pageCount: 0\n        },\n        {\n            id: 1,\n            name: 'Book 1',\n            pageCount: 0\n        },\n        {\n            id: 2,\n            name: 'Book 2',\n            pageCount: 0\n        },\n        {\n            id: 3,\n            name: 'Book 22',\n            pageCount: 0\n        },\n        {\n            id: 4,\n            name: 'Book 222',\n            pageCount: 0\n        }\n    ];\n\n    getAllBooks(): Observable<IBook[]> {\n        return of<IBook[]>(this.books).pipe(\n            delay(2000)\n        );\n    }\n\n    addBook(book: IBook): Observable<IBook> {\n        this.books.push(book);\n        return of(book).pipe(\n            delay(2000)\n        );\n    }\n\n    removeBook(id: number): Observable<number> {\n        const index = this.books.findIndex(x => x.id === id);\n        if(index >= 0) {\n            this.books.splice(index, 1);\n        }\n\n        return of(id).pipe(\n            delay(2000)\n        )\n    }\n}\n```\n\n# BooksStore implementation\n\nLet’s start creating simple SignalStore.\n\n```js\nexport const BooksStore = signalStore(\n    withEntities<IBook>()\n)\n```\n\n<div class=\"content-ad\"></div>\n\n지금은 상태를 유지하기에 충분합니다. 이것을 어떤 컴포넌트에 주입하여 사용할 수 있습니다.\n\n```js\n@Component({\n    selector: 'app-root',\n    standalone: true,\n    template: `\n      <div>\n          @for (book of booksStore.entities(); track book.id) {\n              <div>\n                  <div>{ book.name }</div>\n              </div>\n          }\n      </div>\n  `,\n    providers: [BooksStore]\n})\nexport class App {\n    booksStore = inject(BooksStore);\n}\n```\n\n작업은 매우 간단해 보이지만, 미들웨어로 만들면 훨씬 강력해질 것입니다. 이는 BooksStore가 데이터(우리의 경우 책 목록)를 서버와 동기화하는 책임을 져야 한다는 것을 의미합니다. DataService는 어디에서나 사용하면 안 되며 오직 BooksStore에서만 사용되어야 합니다. 이를 위해 해야 할 일을 설명해 보겠습니다.\n\n- BooksStore에 모든 책을 가져오는 함수 추가\n- BooksStore에 책을 추가하는 함수 추가\n- BooksStore에서 책을 제거하는 함수 추가\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 스토어에 있는 모든 책을 가져오는 것을 제안합니다. 이는 BooksStore가 Angular 컴포넌트에 주입될 때 서버에서 데이터를 가져오기 시작한다는 것을 의미합니다. (엄격하게 판단하지 마세요, SignalStore 훅을 보여주기 위해 이렇게 작성되었지만, 단순히 훅에서 메서드로 이동할 수 있습니다. 책을 추가하거나 제거하는 기능처럼).\n\nonInit 훅에서 모든 책을 가져오는 BooksStore\n\n```js\nexport const BooksStore = signalStore(\n    withEntities<IBook>(),\n    withHooks({\n        onInit(store, dataService = inject(DataService)) {\n            dataService.getAllBooks().pipe(\n                takeUntilDestroyed(),\n                tap(books => patchState(store, setEntities(books))), \n            ).subscribe();\n        },\n        onDestroy(store) {\n            console.log('Book store destroy', store);\n        },\n    }),\n)\n```\n\n이제, 책을 추가하고 제거하는 기능을 추가해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nexport const BooksStore = signalStore(\n    withEntities<IBook>(),\n    withHooks({\n        onInit(store, dataService = inject(DataService)) {\n            dataService.getAllBooks().pipe(\n                takeUntilDestroyed(), \n                // 서버에서 새 책 목록으로 상점을 패치하는 부분\n                tap(books => patchState(store, setEntities(books))),\n            ).subscribe();\n        },\n        onDestroy(store) {\n            console.log('BooksStore destroy', store);\n        },\n    }),\n    withMethods((store, dataService = inject(DataService)) => ({\n        \n        // 책 추가 함수\n        add: rxMethod<IBook>(\n            pipe(\n                switchMap(book => {\n                    return dataService.addBook(book).pipe(\n                        // 응답 처리를 단순화하기위한 특수 NgRx 연산자\n                        tapResponse({\n                            next: (book) => {\n                                // 상태 패치\n                                // 책이 추가 또는 업데이트 될 것임 \n                                patchState(store, addEntity(book))\n                            },\n                            error: console.error,\n                            finalize: () => console.log,\n                        })\n                    )\n                })\n            )\n        ),\n        \n        // 책 삭제 함수\n        remove: rxMethod<IBook>(\n            pipe(\n                switchMap(book => {\n                    return dataService.removeBook(book.id).pipe(\n                        // 응답 처리를 단순화하기위한 특수 NgRx 연산자\n                        tapResponse({\n                            next: (book) => {\n                                // 상태 패치\n                                // 책이 제거될 것임\n                                patchState(store, removeEntity(book))\n                            },\n                            error: console.error,\n                            finalize: () => console.log,\n                        })\n                    )\n                })\n            )\n        ),\n    }))\n)\r\n```\n\nSignalStore와 거의 끝났어요. 하지만, 데이터를 가져오는 동안 로딩 표시를 해야 한다면 어떻게 할까요? 상점 안에 객체가 있는 경우 (리스트가 아닌 경우) isLoading 속성을 추가하여 객체의 모든 속성이 시그널 (DeepSignal)이 되므로, 이 isLoading 속성에 신호 속성으로 액세스할 수 있습니다. 그러나 엔터티 목록이 있는 경우, SignalStore는 엔터티의 상점에서 추가 신호 속성을 추가하는 기능을 제공하지 않습니다. 이를 통해 로딩과 같은 추가 상태 또는 엔터티 목록이있는 상점의 정보에 액세스 할 수 있습니다.\n\n객체가 있는 상점을 살펴보겠습니다. 여기서는 isLoading을 신호 속성으로 추가하고 계산된 신호 속성으로 count를 추가할 수 있습니다.\n\n```js\ntype BooksState = {\n    books: IBook[];\n// 로딩을 나타내기 위한 객체의 추가 속성.\n    isLoading: boolean;\n};\n\nconst initialState: BooksState = {\n    books: [],\n    isLoading: false,\n};\n\nexport const BooksStore = signalStore(\n    // withEntities 대신 withState를 사용하여 생성된 상점\n    withState(initialState),\n\n    // 주입된 BookStore의 계산된 신호 속성 추가\n    withComputed(({ booksStore }) => ({\n        // booksCount는 BookStore의 주입된 인스턴스에서 계산된 신호 속성으로 사용 가능\n        booksCount: computed(() => booksStore().entities().length),\n    })),\n\n    withMethods((store, dataService = inject(DataService)) => ({\n        load: rxMethod<void>(\n            pipe(\n                distinctUntilChanged(),\n                //\n                tap(() => patchState(store, { isLoading: true })),\n                switchMap(() => {\n                    return dataService.getAllBooks().pipe(\n                        tapResponse({\n                            next: (books) => {\n                                patchState(store, { books })\n                            },\n                            error: console.error,\n                            finalize: () => patchState(store, { isLoading: false }),\n                        })\n                    );\n                })\n            )\n        )\n    }))\n);\r\n```\n\n<div class=\"content-ad\"></div>\n\n빙고를 외쳐 보세요! 우리는 SignalStore를 entities가 아닌 books라는 속성을 가진 객체와 함께 사용할 수 있습니다. 이 속성은 책의 배열인데요. 하지만 안타깝게도, 만약 add(book: IBook) 또는 update(book: IBook) 메소드를 추가한다면, books 배열에서 단일 책 항목을 패치할 수 없게 됩니다. 그래서 우리는 새로운 필터링되거나 확장된 책 배열로 booksStore.books 시그널 속성을 덮어쓸 수밖에 없습니다.\n\n다행히도, JavaScript 절을 다시 살펴본 뒤 이 문제를 해결할 수 있습니다. 다행히도 SignalStore 아키텍처를 사용하면 이 문제를 해결하고 BooksStore의 @Injectable() 동작을 유지할 수 있습니다.\n\n따라서, 이 기사를 위한 BooksStore의 최종 버전은 다음과 같이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport {patchState, signalStore, withHooks, withMethods} from \"@ngrx/signals\";\r\nimport {addEntity, removeEntity, setEntities, withEntities} from \"@ngrx/signals/entities\";\r\nimport {IBook} from \"../interfaces/book.interface\";\r\nimport {inject, signal} from \"@angular/core\";\r\nimport {DataService} from \"../services/data.service\";\r\nimport {rxMethod} from \"@ngrx/signals/rxjs-interop\";\r\nimport {pipe, switchMap, tap} from \"rxjs\";\r\nimport {tapResponse} from \"@ngrx/operators\";\r\nimport {takeUntilDestroyed} from \"@angular/core/rxjs-interop\";\r\n\r\n// 새로운 인스턴스가 생성될 때마다 isLoading 플래그를 가진 signalStore 컨텍스트에 isLoading을 추가하는 클래스 정의\r\nexport const BooksStore = function() {\r\n    let isLoading = signal(false);\r\n\r\n    return signalStore(\r\n        withEntities<IBook>(),\r\n        withHooks({\r\n            onInit(store, dataService = inject(DataService)) {\r\n                isLoading.set(true);\r\n                dataService.getAllBooks().pipe(\r\n                    takeUntilDestroyed(),\r\n                    tap(books => patchState(store, setEntities(books))),\r\n                    tap(() => isLoading.set(false))\r\n                ).subscribe();\r\n            },\r\n            onDestroy(store) {\r\n                console.log('count on destroy', store);\r\n            },\r\n        }),\r\n        withMethods((store, dataService = inject(DataService)) => ({\r\n            isLoading,\r\n            add: rxMethod<IBook>(\r\n                pipe(\r\n                    tap(() => isLoading.set(true)),\r\n                    switchMap(book => {\r\n                        return dataService.addBook(book).pipe(\r\n                            tapResponse({\r\n                                next: (book) => {\r\n                                    patchState(store, addEntity(book));\r\n                                },\r\n                                error: console.error,\r\n                                finalize: () => isLoading.set(false),\r\n                            })\r\n                        );\r\n                    })\r\n                )\r\n            ),\r\n            remove: rxMethod<IBook>(\r\n                pipe(\r\n                    tap(() => isLoading.set(true)),\r\n                    switchMap(book => {\r\n                        return dataService.removeBook(book.id).pipe(\r\n                            tapResponse({\r\n                                next: (book) => {\r\n                                    patchState(store, removeEntity(book));\r\n                                },\r\n                                error: console.error,\r\n                                finalize: () => isLoading.set(false),\r\n                            })\r\n                        );\r\n                    })\r\n                )\r\n            ),\r\n        }))\r\n    );\r\n}();\r\n```\r\n\r\nBooksStore 클래스 작성이 완료되었습니다. 이제 사용 방법을 알아보고 controller 내 코드 양이 줄어드는지 확인해봅시다.\r\n\r\n# Controller 구현\r\n\r\n```js\r\n@Component({\r\n    selector: 'app-root',\r\n    standalone: true,\r\n    template: `\r\n      @if (bookStore.isLoading()) {\r\n          <div class=\"backdrop\">\r\n              <div class=\"spinner\"></div>\r\n          </div>\r\n      }\r\n      <div>\r\n          @for (book of booksStore.entities(); track book.id) {\r\n              <div>\r\n                  <div>{ book.name }</div>\r\n                  <button (click)=\"booksStore.remove(book)\">remove book</button>\r\n              </div>\r\n          }\r\n          <button (click)=\"addBook()\">Add book</button>\r\n      </div>\r\n  `,\r\n    providers: [BooksStore]\r\n})\r\nexport class App {\r\n    booksStore = inject(BooksStore);\r\n\r\n    addBook() {\r\n        this.booksStore.add({\r\n            id: RandomHelper.getRandomInt(10000, 99999),\r\n            name: RandomHelper.getRandomString(5),\r\n            pageCount: 0\r\n        });\r\n    }\r\n}\r\n```\n\n<div class=\"content-ad\"></div>\n\n보시다시피 상점 사용법은 꽤 간단합니다. 프로젝트 전반에 걸쳐 데이터 저장소를 사용해야 할 경우, 그것은 꽤 좋고 안정적이며 빠르게 사용할 수 있는 방법입니다. 페이지의 변경 사항은 Angular의 존리스(Zoneless) 접근 방식을 통해 자동으로 적용됩니다.\n\n```js\nbootstrapApplication(AppComponent, {\n    providers: [\n        provideExperimentalZonelessChangeDetection()\n    ]\n}).then();\n```\n\n# 그리고 한 가지 더 :)\n\n일부 Observable을 구독할 때 하는 것과 같이 변경 사항에 코드를 실행해야 할 필요가 있다면, Angular Signal 효과로 쉽게 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n    selector: 'app-root',\n    standalone: true,\n    template: `\n      <div>\n          @for (book of booksStore.entities(); track book.id) {\n              <div>\n                  <div>{ book.name }</div>\n                  <button (click)=\"booksStore.remove(book)\">remove book</button>\n              </div>\n          }\n          <button (click)=\"addBook()\">Add book</button>\n      </div>\n  `,\n    providers: [BooksStore]\n})\nexport class App {\n    booksStore = inject(BooksStore);\n\n    constructor() {\n        effect(() => {\n            const isLoading = this.booksStore.isLoading();\n\n            if (isLoading) {\n                console.log('Books loading')\n            } else {\n                console.log('Books loaded', untracked(this.booksStore.entities()))\n            }\n        });\n    }\n\n    addBook() {\n        this.booksStore.add({\n            id: RandomHelper.getRandomInt(10000, 99999),\n            name: RandomHelper.getRandomString(5),\n            pageCount: 0\n        })\n    }\n}\n```\n\neffect()에 전달된 화살표 함수는 this.booksStore.isLoading()의 변경 사항마다 실행됩니다. untracked()로 꾸며진 this.booksStore.entities() 변경은 무시됩니다.\n\n시간 내어주셔서 감사합니다. 이 글이 누군가에게 유용하길 바랍니다. 이것이 제 첫 번째 글입니다 :)\n의견이나 질문이 있다면 댓글이나 직접 메시지로 자유롭게 남겨주세요.\n\n다음 글이 제가 작성한 다양한 형식과 데이터 서비스로 프로젝트 간에 사용할 수 있는 추상화된 스토어 로직에 관한 글이 필요하시다면 알려주세요.\n\n<div class=\"content-ad\"></div>\n\n# 예시 ( git & stackblitz )\n\n- git: [https://github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach](https://github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach)\n\n- stackblitz: [https://stackblitz.com/~/github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach?file=tsconfig.json](https://stackblitz.com/~/github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach?file=tsconfig.json)\n\n![GIF](https://miro.medium.com/v2/resize:fit:1200/1*7FTwCxciVW1J0WIMOenfpA.gif)\n\n<div class=\"content-ad\"></div>\n\n# 유용한 링크:\n\n- ngneat/elf store: [여기를 클릭하세요](https://ngneat.github.io/elf/docs/store)\n- Angular zoneless: [여기를 클릭하세요](https://angular.dev/guide/experimental/zoneless)\n- NgRx SignalStore 문서: [여기를 클릭하세요](https://ngrx.io/guide/signals/signal-store)\n\n<div class=\"content-ad\"></div>\n\nDeepSignal: [https://ngrx.io/api/signals/DeepSignal](https://ngrx.io/api/signals/DeepSignal)\n\nAngular Signal effect: [https://angular.dev/guide/signals#effects](https://angular.dev/guide/signals#effects)\n\nAuthor's LinkedIn: [https://www.linkedin.com/in/serhii-zhydetskyi-80a7789b/](https://www.linkedin.com/in/serhii-zhydetskyi-80a7789b/)","ogImage":{"url":"/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png"},"coverImage":"/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png\" alt=\"2024-07-01-NgRxSignalStorestatemanagementwithAngularzonelessapp_0.png\"></p>\n<p>여러분은 이미 새로운 Angular 도구인 Signals에 대해 알고 있을 것입니다. 내 의견으로는, 이는 매우 강력하고 편리한 도구로, 컨트롤러의 코드 양을 줄이고 개발 과정을 더 빠르게 만들어줍니다. 동시에, NgRx가 제안하는 상태 관리를 위한 또 다른 도구에 대해 이야기해보고 싶습니다. 이 방식을 사용하면 뷰 컨트롤러에 코드가 적어지며 페이지 효율성이 높아지고, 컨트롤러에서 부작용을 처리할 필요가 없으며 zoneless입니다. 또한 상태 관리가 만병통치약이 아니라는 것을 기억해야 하며, 필요한 프로젝트에서만 사용해야 합니다. 그렇지 않으면 페이지/프로젝트에 복잡성만 더할 수 있습니다.</p>\n<h1>사례 설명</h1>\n<p>서버에서 가져온 책 목록이 있는 상황을 상상해보겠습니다. 이들을 상태로 유지하고, 제거하거나 책을 추가할 수 있는 페이지에 표시하는 작업을 수행해야 합니다(NgRx 문서에서 가져온 케이스입니다).</p>\n<div class=\"content-ad\"></div>\n<p>우리가 할 수 있는 일은 무엇일까요? 우리는 모든 복잡성을 갖춘 NgRx 스토어를 사용할 수 있고, ngneat/elf store와 같은 더 간단한 솔루션을 사용할 수도 있어요. 이러한 기술을 사용하면 여전히 데이터 스트림(옵저버블)과 zone.js와 함께 작업할 것이지만, Angular의 마지막 18번째 버전은 zoneless change detection 접근 방식을 제안하고 있어요. 네, 현재는 실험적인 부분이라고 할 수 있지만, Ivy의 경우를 상기해보세요. Angular 8에서는 선택 사항이었지만, Angular 9에서는 표준이 되었고 View Engine을 사용하려면 다시 거슬러 올라가야 했어요. 그래서, 지금부터는 이 공개된(NgRx 팀이 발표한) 새로운 도구를 사용해 보려고 해요 (이 글을 작성하는 시점에는 RC 상태에요). 이제부터는 더 많은 코드와 간결한 설명으로 진행할게요 :)</p>\n<p>이 글에서 설명된 방법은 NgRx SignalStore 문서에서 영감을 받았어요.</p>\n<h1>가짜 DataService 구현</h1>\n<p>서버에서 책 목록을 반환, 추가, 삭제하는 DataService가 있어요. 우리의 경우에는 서버 요청 수명을 흉내내기 위해 하드 코딩된 책 목록과 지연된 응답이 있는 서비스가 있어요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">Injectable</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@angular/core\"</span>;\n<span class=\"hljs-keyword\">import</span> {delay, map, <span class=\"hljs-title class_\">Observable</span>, <span class=\"hljs-keyword\">of</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"rxjs\"</span>;\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">IBook</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../interfaces/book.interface\"</span>;\n\n<span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">IBook</span> {\n    <span class=\"hljs-attr\">id</span>: number,\n    <span class=\"hljs-attr\">name</span>: string,\n    <span class=\"hljs-attr\">pageCount</span>: number\n}\n\n@<span class=\"hljs-title class_\">Injectable</span>({<span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">\"root\"</span>})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataService</span> {\n\n    private <span class=\"hljs-attr\">books</span>: <span class=\"hljs-title class_\">IBook</span>[] = [\n        {\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">0</span>,\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Book 0'</span>,\n            <span class=\"hljs-attr\">pageCount</span>: <span class=\"hljs-number\">0</span>\n        },\n        {\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Book 1'</span>,\n            <span class=\"hljs-attr\">pageCount</span>: <span class=\"hljs-number\">0</span>\n        },\n        {\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Book 2'</span>,\n            <span class=\"hljs-attr\">pageCount</span>: <span class=\"hljs-number\">0</span>\n        },\n        {\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>,\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Book 22'</span>,\n            <span class=\"hljs-attr\">pageCount</span>: <span class=\"hljs-number\">0</span>\n        },\n        {\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">4</span>,\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Book 222'</span>,\n            <span class=\"hljs-attr\">pageCount</span>: <span class=\"hljs-number\">0</span>\n        }\n    ];\n\n    <span class=\"hljs-title function_\">getAllBooks</span>(): <span class=\"hljs-title class_\">Observable</span>&#x3C;<span class=\"hljs-title class_\">IBook</span>[]> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">of</span>&#x3C;<span class=\"hljs-title class_\">IBook</span>[]>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books</span>).<span class=\"hljs-title function_\">pipe</span>(\n            <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-number\">2000</span>)\n        );\n    }\n\n    <span class=\"hljs-title function_\">addBook</span>(<span class=\"hljs-attr\">book</span>: <span class=\"hljs-title class_\">IBook</span>): <span class=\"hljs-title class_\">Observable</span>&#x3C;<span class=\"hljs-title class_\">IBook</span>> {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books</span>.<span class=\"hljs-title function_\">push</span>(book);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">of</span>(book).<span class=\"hljs-title function_\">pipe</span>(\n            <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-number\">2000</span>)\n        );\n    }\n\n    <span class=\"hljs-title function_\">removeBook</span>(<span class=\"hljs-attr\">id</span>: number): <span class=\"hljs-title class_\">Observable</span>&#x3C;number> {\n        <span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books</span>.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x.<span class=\"hljs-property\">id</span> === id);\n        <span class=\"hljs-keyword\">if</span>(index >= <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books</span>.<span class=\"hljs-title function_\">splice</span>(index, <span class=\"hljs-number\">1</span>);\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">of</span>(id).<span class=\"hljs-title function_\">pipe</span>(\n            <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-number\">2000</span>)\n        )\n    }\n}\n</code></pre>\n<h1>BooksStore implementation</h1>\n<p>Let’s start creating simple SignalStore.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">BooksStore</span> = <span class=\"hljs-title function_\">signalStore</span>(\n    withEntities&#x3C;<span class=\"hljs-title class_\">IBook</span>>()\n)\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>지금은 상태를 유지하기에 충분합니다. 이것을 어떤 컴포넌트에 주입하여 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n    <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-root'</span>,\n    <span class=\"hljs-attr\">standalone</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n      &#x3C;div>\n          @for (book of booksStore.entities(); track book.id) {\n              &#x3C;div>\n                  &#x3C;div>{ book.name }&#x3C;/div>\n              &#x3C;/div>\n          }\n      &#x3C;/div>\n  `</span>,\n    <span class=\"hljs-attr\">providers</span>: [<span class=\"hljs-title class_\">BooksStore</span>]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> {\n    booksStore = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BooksStore</span>);\n}\n</code></pre>\n<p>작업은 매우 간단해 보이지만, 미들웨어로 만들면 훨씬 강력해질 것입니다. 이는 BooksStore가 데이터(우리의 경우 책 목록)를 서버와 동기화하는 책임을 져야 한다는 것을 의미합니다. DataService는 어디에서나 사용하면 안 되며 오직 BooksStore에서만 사용되어야 합니다. 이를 위해 해야 할 일을 설명해 보겠습니다.</p>\n<ul>\n<li>BooksStore에 모든 책을 가져오는 함수 추가</li>\n<li>BooksStore에 책을 추가하는 함수 추가</li>\n<li>BooksStore에서 책을 제거하는 함수 추가</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>이 예시에서는 스토어에 있는 모든 책을 가져오는 것을 제안합니다. 이는 BooksStore가 Angular 컴포넌트에 주입될 때 서버에서 데이터를 가져오기 시작한다는 것을 의미합니다. (엄격하게 판단하지 마세요, SignalStore 훅을 보여주기 위해 이렇게 작성되었지만, 단순히 훅에서 메서드로 이동할 수 있습니다. 책을 추가하거나 제거하는 기능처럼).</p>\n<p>onInit 훅에서 모든 책을 가져오는 BooksStore</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">BooksStore</span> = <span class=\"hljs-title function_\">signalStore</span>(\n    withEntities&#x3C;<span class=\"hljs-title class_\">IBook</span>>(),\n    <span class=\"hljs-title function_\">withHooks</span>({\n        <span class=\"hljs-title function_\">onInit</span>(<span class=\"hljs-params\">store, dataService = inject(DataService)</span>) {\n            dataService.<span class=\"hljs-title function_\">getAllBooks</span>().<span class=\"hljs-title function_\">pipe</span>(\n                <span class=\"hljs-title function_\">takeUntilDestroyed</span>(),\n                <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">books</span> =></span> <span class=\"hljs-title function_\">patchState</span>(store, <span class=\"hljs-title function_\">setEntities</span>(books))), \n            ).<span class=\"hljs-title function_\">subscribe</span>();\n        },\n        <span class=\"hljs-title function_\">onDestroy</span>(<span class=\"hljs-params\">store</span>) {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Book store destroy'</span>, store);\n        },\n    }),\n)\n</code></pre>\n<p>이제, 책을 추가하고 제거하는 기능을 추가해봅시다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">BooksStore</span> = <span class=\"hljs-title function_\">signalStore</span>(\n    withEntities&#x3C;<span class=\"hljs-title class_\">IBook</span>>(),\n    <span class=\"hljs-title function_\">withHooks</span>({\n        <span class=\"hljs-title function_\">onInit</span>(<span class=\"hljs-params\">store, dataService = inject(DataService)</span>) {\n            dataService.<span class=\"hljs-title function_\">getAllBooks</span>().<span class=\"hljs-title function_\">pipe</span>(\n                <span class=\"hljs-title function_\">takeUntilDestroyed</span>(), \n                <span class=\"hljs-comment\">// 서버에서 새 책 목록으로 상점을 패치하는 부분</span>\n                <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">books</span> =></span> <span class=\"hljs-title function_\">patchState</span>(store, <span class=\"hljs-title function_\">setEntities</span>(books))),\n            ).<span class=\"hljs-title function_\">subscribe</span>();\n        },\n        <span class=\"hljs-title function_\">onDestroy</span>(<span class=\"hljs-params\">store</span>) {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'BooksStore destroy'</span>, store);\n        },\n    }),\n    <span class=\"hljs-title function_\">withMethods</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">store, dataService = inject(DataService)</span>) =></span> ({\n        \n        <span class=\"hljs-comment\">// 책 추가 함수</span>\n        <span class=\"hljs-attr\">add</span>: rxMethod&#x3C;<span class=\"hljs-title class_\">IBook</span>>(\n            <span class=\"hljs-title function_\">pipe</span>(\n                <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">book</span> =></span> {\n                    <span class=\"hljs-keyword\">return</span> dataService.<span class=\"hljs-title function_\">addBook</span>(book).<span class=\"hljs-title function_\">pipe</span>(\n                        <span class=\"hljs-comment\">// 응답 처리를 단순화하기위한 특수 NgRx 연산자</span>\n                        <span class=\"hljs-title function_\">tapResponse</span>({\n                            <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">book</span>) =></span> {\n                                <span class=\"hljs-comment\">// 상태 패치</span>\n                                <span class=\"hljs-comment\">// 책이 추가 또는 업데이트 될 것임 </span>\n                                <span class=\"hljs-title function_\">patchState</span>(store, <span class=\"hljs-title function_\">addEntity</span>(book))\n                            },\n                            <span class=\"hljs-attr\">error</span>: <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>,\n                            <span class=\"hljs-attr\">finalize</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>,\n                        })\n                    )\n                })\n            )\n        ),\n        \n        <span class=\"hljs-comment\">// 책 삭제 함수</span>\n        <span class=\"hljs-attr\">remove</span>: rxMethod&#x3C;<span class=\"hljs-title class_\">IBook</span>>(\n            <span class=\"hljs-title function_\">pipe</span>(\n                <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">book</span> =></span> {\n                    <span class=\"hljs-keyword\">return</span> dataService.<span class=\"hljs-title function_\">removeBook</span>(book.<span class=\"hljs-property\">id</span>).<span class=\"hljs-title function_\">pipe</span>(\n                        <span class=\"hljs-comment\">// 응답 처리를 단순화하기위한 특수 NgRx 연산자</span>\n                        <span class=\"hljs-title function_\">tapResponse</span>({\n                            <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">book</span>) =></span> {\n                                <span class=\"hljs-comment\">// 상태 패치</span>\n                                <span class=\"hljs-comment\">// 책이 제거될 것임</span>\n                                <span class=\"hljs-title function_\">patchState</span>(store, <span class=\"hljs-title function_\">removeEntity</span>(book))\n                            },\n                            <span class=\"hljs-attr\">error</span>: <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>,\n                            <span class=\"hljs-attr\">finalize</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>,\n                        })\n                    )\n                })\n            )\n        ),\n    }))\n)\n</code></pre>\n<p>SignalStore와 거의 끝났어요. 하지만, 데이터를 가져오는 동안 로딩 표시를 해야 한다면 어떻게 할까요? 상점 안에 객체가 있는 경우 (리스트가 아닌 경우) isLoading 속성을 추가하여 객체의 모든 속성이 시그널 (DeepSignal)이 되므로, 이 isLoading 속성에 신호 속성으로 액세스할 수 있습니다. 그러나 엔터티 목록이 있는 경우, SignalStore는 엔터티의 상점에서 추가 신호 속성을 추가하는 기능을 제공하지 않습니다. 이를 통해 로딩과 같은 추가 상태 또는 엔터티 목록이있는 상점의 정보에 액세스 할 수 있습니다.</p>\n<p>객체가 있는 상점을 살펴보겠습니다. 여기서는 isLoading을 신호 속성으로 추가하고 계산된 신호 속성으로 count를 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">BooksState</span> = {\n    <span class=\"hljs-attr\">books</span>: <span class=\"hljs-title class_\">IBook</span>[];\n<span class=\"hljs-comment\">// 로딩을 나타내기 위한 객체의 추가 속성.</span>\n    <span class=\"hljs-attr\">isLoading</span>: boolean;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-title class_\">BooksState</span> = {\n    <span class=\"hljs-attr\">books</span>: [],\n    <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>,\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">BooksStore</span> = <span class=\"hljs-title function_\">signalStore</span>(\n    <span class=\"hljs-comment\">// withEntities 대신 withState를 사용하여 생성된 상점</span>\n    <span class=\"hljs-title function_\">withState</span>(initialState),\n\n    <span class=\"hljs-comment\">// 주입된 BookStore의 계산된 신호 속성 추가</span>\n    <span class=\"hljs-title function_\">withComputed</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ booksStore }</span>) =></span> ({\n        <span class=\"hljs-comment\">// booksCount는 BookStore의 주입된 인스턴스에서 계산된 신호 속성으로 사용 가능</span>\n        <span class=\"hljs-attr\">booksCount</span>: <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">booksStore</span>().<span class=\"hljs-title function_\">entities</span>().<span class=\"hljs-property\">length</span>),\n    })),\n\n    <span class=\"hljs-title function_\">withMethods</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">store, dataService = inject(DataService)</span>) =></span> ({\n        <span class=\"hljs-attr\">load</span>: rxMethod&#x3C;<span class=\"hljs-keyword\">void</span>>(\n            <span class=\"hljs-title function_\">pipe</span>(\n                <span class=\"hljs-title function_\">distinctUntilChanged</span>(),\n                <span class=\"hljs-comment\">//</span>\n                <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">patchState</span>(store, { <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">true</span> })),\n                <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\">() =></span> {\n                    <span class=\"hljs-keyword\">return</span> dataService.<span class=\"hljs-title function_\">getAllBooks</span>().<span class=\"hljs-title function_\">pipe</span>(\n                        <span class=\"hljs-title function_\">tapResponse</span>({\n                            <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">books</span>) =></span> {\n                                <span class=\"hljs-title function_\">patchState</span>(store, { books })\n                            },\n                            <span class=\"hljs-attr\">error</span>: <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>,\n                            <span class=\"hljs-attr\">finalize</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">patchState</span>(store, { <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span> }),\n                        })\n                    );\n                })\n            )\n        )\n    }))\n);\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>빙고를 외쳐 보세요! 우리는 SignalStore를 entities가 아닌 books라는 속성을 가진 객체와 함께 사용할 수 있습니다. 이 속성은 책의 배열인데요. 하지만 안타깝게도, 만약 add(book: IBook) 또는 update(book: IBook) 메소드를 추가한다면, books 배열에서 단일 책 항목을 패치할 수 없게 됩니다. 그래서 우리는 새로운 필터링되거나 확장된 책 배열로 booksStore.books 시그널 속성을 덮어쓸 수밖에 없습니다.</p>\n<p>다행히도, JavaScript 절을 다시 살펴본 뒤 이 문제를 해결할 수 있습니다. 다행히도 SignalStore 아키텍처를 사용하면 이 문제를 해결하고 BooksStore의 @Injectable() 동작을 유지할 수 있습니다.</p>\n<p>따라서, 이 기사를 위한 BooksStore의 최종 버전은 다음과 같이 보일 것입니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {patchState, signalStore, withHooks, withMethods} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@ngrx/signals\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {addEntity, removeEntity, setEntities, withEntities} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@ngrx/signals/entities\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">IBook</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../interfaces/book.interface\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {inject, signal} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@angular/core\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">DataService</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../services/data.service\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {rxMethod} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@ngrx/signals/rxjs-interop\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {pipe, switchMap, tap} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"rxjs\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {tapResponse} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@ngrx/operators\"</span>;\r\n<span class=\"hljs-keyword\">import</span> {takeUntilDestroyed} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@angular/core/rxjs-interop\"</span>;\r\n\r\n<span class=\"hljs-comment\">// 새로운 인스턴스가 생성될 때마다 isLoading 플래그를 가진 signalStore 컨텍스트에 isLoading을 추가하는 클래스 정의</span>\r\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">BooksStore</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\r\n    <span class=\"hljs-keyword\">let</span> isLoading = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-literal\">false</span>);\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">signalStore</span>(\r\n        withEntities&#x3C;<span class=\"hljs-title class_\">IBook</span>>(),\r\n        <span class=\"hljs-title function_\">withHooks</span>({\r\n            <span class=\"hljs-title function_\">onInit</span>(<span class=\"hljs-params\">store, dataService = inject(DataService)</span>) {\r\n                isLoading.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>);\r\n                dataService.<span class=\"hljs-title function_\">getAllBooks</span>().<span class=\"hljs-title function_\">pipe</span>(\r\n                    <span class=\"hljs-title function_\">takeUntilDestroyed</span>(),\r\n                    <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">books</span> =></span> <span class=\"hljs-title function_\">patchState</span>(store, <span class=\"hljs-title function_\">setEntities</span>(books))),\r\n                    <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\">() =></span> isLoading.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">false</span>))\r\n                ).<span class=\"hljs-title function_\">subscribe</span>();\r\n            },\r\n            <span class=\"hljs-title function_\">onDestroy</span>(<span class=\"hljs-params\">store</span>) {\r\n                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'count on destroy'</span>, store);\r\n            },\r\n        }),\r\n        <span class=\"hljs-title function_\">withMethods</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">store, dataService = inject(DataService)</span>) =></span> ({\r\n            isLoading,\r\n            <span class=\"hljs-attr\">add</span>: rxMethod&#x3C;<span class=\"hljs-title class_\">IBook</span>>(\r\n                <span class=\"hljs-title function_\">pipe</span>(\r\n                    <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\">() =></span> isLoading.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>)),\r\n                    <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">book</span> =></span> {\r\n                        <span class=\"hljs-keyword\">return</span> dataService.<span class=\"hljs-title function_\">addBook</span>(book).<span class=\"hljs-title function_\">pipe</span>(\r\n                            <span class=\"hljs-title function_\">tapResponse</span>({\r\n                                <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">book</span>) =></span> {\r\n                                    <span class=\"hljs-title function_\">patchState</span>(store, <span class=\"hljs-title function_\">addEntity</span>(book));\r\n                                },\r\n                                <span class=\"hljs-attr\">error</span>: <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>,\r\n                                <span class=\"hljs-attr\">finalize</span>: <span class=\"hljs-function\">() =></span> isLoading.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">false</span>),\r\n                            })\r\n                        );\r\n                    })\r\n                )\r\n            ),\r\n            <span class=\"hljs-attr\">remove</span>: rxMethod&#x3C;<span class=\"hljs-title class_\">IBook</span>>(\r\n                <span class=\"hljs-title function_\">pipe</span>(\r\n                    <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\">() =></span> isLoading.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">true</span>)),\r\n                    <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">book</span> =></span> {\r\n                        <span class=\"hljs-keyword\">return</span> dataService.<span class=\"hljs-title function_\">removeBook</span>(book.<span class=\"hljs-property\">id</span>).<span class=\"hljs-title function_\">pipe</span>(\r\n                            <span class=\"hljs-title function_\">tapResponse</span>({\r\n                                <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">book</span>) =></span> {\r\n                                    <span class=\"hljs-title function_\">patchState</span>(store, <span class=\"hljs-title function_\">removeEntity</span>(book));\r\n                                },\r\n                                <span class=\"hljs-attr\">error</span>: <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">error</span>,\r\n                                <span class=\"hljs-attr\">finalize</span>: <span class=\"hljs-function\">() =></span> isLoading.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-literal\">false</span>),\r\n                            })\r\n                        );\r\n                    })\r\n                )\r\n            ),\r\n        }))\r\n    );\r\n}();\n</code></pre>\n<p>BooksStore 클래스 작성이 완료되었습니다. 이제 사용 방법을 알아보고 controller 내 코드 양이 줄어드는지 확인해봅시다.</p>\n<h1>Controller 구현</h1>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\r\n    <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-root'</span>,\r\n    <span class=\"hljs-attr\">standalone</span>: <span class=\"hljs-literal\">true</span>,\r\n    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\r\n      @if (bookStore.isLoading()) {\r\n          &#x3C;div class=\"backdrop\">\r\n              &#x3C;div class=\"spinner\">&#x3C;/div>\r\n          &#x3C;/div>\r\n      }\r\n      &#x3C;div>\r\n          @for (book of booksStore.entities(); track book.id) {\r\n              &#x3C;div>\r\n                  &#x3C;div>{ book.name }&#x3C;/div>\r\n                  &#x3C;button (click)=\"booksStore.remove(book)\">remove book&#x3C;/button>\r\n              &#x3C;/div>\r\n          }\r\n          &#x3C;button (click)=\"addBook()\">Add book&#x3C;/button>\r\n      &#x3C;/div>\r\n  `</span>,\r\n    <span class=\"hljs-attr\">providers</span>: [<span class=\"hljs-title class_\">BooksStore</span>]\r\n})\r\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> {\r\n    booksStore = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BooksStore</span>);\r\n\r\n    <span class=\"hljs-title function_\">addBook</span>(<span class=\"hljs-params\"></span>) {\r\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksStore</span>.<span class=\"hljs-title function_\">add</span>({\r\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">RandomHelper</span>.<span class=\"hljs-title function_\">getRandomInt</span>(<span class=\"hljs-number\">10000</span>, <span class=\"hljs-number\">99999</span>),\r\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">RandomHelper</span>.<span class=\"hljs-title function_\">getRandomString</span>(<span class=\"hljs-number\">5</span>),\r\n            <span class=\"hljs-attr\">pageCount</span>: <span class=\"hljs-number\">0</span>\r\n        });\r\n    }\r\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>보시다시피 상점 사용법은 꽤 간단합니다. 프로젝트 전반에 걸쳐 데이터 저장소를 사용해야 할 경우, 그것은 꽤 좋고 안정적이며 빠르게 사용할 수 있는 방법입니다. 페이지의 변경 사항은 Angular의 존리스(Zoneless) 접근 방식을 통해 자동으로 적용됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">bootstrapApplication</span>(<span class=\"hljs-title class_\">AppComponent</span>, {\n    <span class=\"hljs-attr\">providers</span>: [\n        <span class=\"hljs-title function_\">provideExperimentalZonelessChangeDetection</span>()\n    ]\n}).<span class=\"hljs-title function_\">then</span>();\n</code></pre>\n<h1>그리고 한 가지 더 :)</h1>\n<p>일부 Observable을 구독할 때 하는 것과 같이 변경 사항에 코드를 실행해야 할 필요가 있다면, Angular Signal 효과로 쉽게 할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n    <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-root'</span>,\n    <span class=\"hljs-attr\">standalone</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n      &#x3C;div>\n          @for (book of booksStore.entities(); track book.id) {\n              &#x3C;div>\n                  &#x3C;div>{ book.name }&#x3C;/div>\n                  &#x3C;button (click)=\"booksStore.remove(book)\">remove book&#x3C;/button>\n              &#x3C;/div>\n          }\n          &#x3C;button (click)=\"addBook()\">Add book&#x3C;/button>\n      &#x3C;/div>\n  `</span>,\n    <span class=\"hljs-attr\">providers</span>: [<span class=\"hljs-title class_\">BooksStore</span>]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> {\n    booksStore = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BooksStore</span>);\n\n    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">effect</span>(<span class=\"hljs-function\">() =></span> {\n            <span class=\"hljs-keyword\">const</span> isLoading = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksStore</span>.<span class=\"hljs-title function_\">isLoading</span>();\n\n            <span class=\"hljs-keyword\">if</span> (isLoading) {\n                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Books loading'</span>)\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Books loaded'</span>, <span class=\"hljs-title function_\">untracked</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksStore</span>.<span class=\"hljs-title function_\">entities</span>()))\n            }\n        });\n    }\n\n    <span class=\"hljs-title function_\">addBook</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksStore</span>.<span class=\"hljs-title function_\">add</span>({\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">RandomHelper</span>.<span class=\"hljs-title function_\">getRandomInt</span>(<span class=\"hljs-number\">10000</span>, <span class=\"hljs-number\">99999</span>),\n            <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">RandomHelper</span>.<span class=\"hljs-title function_\">getRandomString</span>(<span class=\"hljs-number\">5</span>),\n            <span class=\"hljs-attr\">pageCount</span>: <span class=\"hljs-number\">0</span>\n        })\n    }\n}\n</code></pre>\n<p>effect()에 전달된 화살표 함수는 this.booksStore.isLoading()의 변경 사항마다 실행됩니다. untracked()로 꾸며진 this.booksStore.entities() 변경은 무시됩니다.</p>\n<p>시간 내어주셔서 감사합니다. 이 글이 누군가에게 유용하길 바랍니다. 이것이 제 첫 번째 글입니다 :)\n의견이나 질문이 있다면 댓글이나 직접 메시지로 자유롭게 남겨주세요.</p>\n<p>다음 글이 제가 작성한 다양한 형식과 데이터 서비스로 프로젝트 간에 사용할 수 있는 추상화된 스토어 로직에 관한 글이 필요하시다면 알려주세요.</p>\n<div class=\"content-ad\"></div>\n<h1>예시 ( git &#x26; stackblitz )</h1>\n<ul>\n<li>\n<p>git: <a href=\"https://github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach\" rel=\"nofollow\" target=\"_blank\">https://github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach</a></p>\n</li>\n<li>\n<p>stackblitz: <a href=\"https://stackblitz.com/~/github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach?file=tsconfig.json\" rel=\"nofollow\" target=\"_blank\">https://stackblitz.com/~/github.com/SerhiiZhydetskyi/stackblitz-rxjs-signals-approach?file=tsconfig.json</a></p>\n</li>\n</ul>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*7FTwCxciVW1J0WIMOenfpA.gif\" alt=\"GIF\"></p>\n<div class=\"content-ad\"></div>\n<h1>유용한 링크:</h1>\n<ul>\n<li>ngneat/elf store: <a href=\"https://ngneat.github.io/elf/docs/store\" rel=\"nofollow\" target=\"_blank\">여기를 클릭하세요</a></li>\n<li>Angular zoneless: <a href=\"https://angular.dev/guide/experimental/zoneless\" rel=\"nofollow\" target=\"_blank\">여기를 클릭하세요</a></li>\n<li>NgRx SignalStore 문서: <a href=\"https://ngrx.io/guide/signals/signal-store\" rel=\"nofollow\" target=\"_blank\">여기를 클릭하세요</a></li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>DeepSignal: <a href=\"https://ngrx.io/api/signals/DeepSignal\" rel=\"nofollow\" target=\"_blank\">https://ngrx.io/api/signals/DeepSignal</a></p>\n<p>Angular Signal effect: <a href=\"https://angular.dev/guide/signals#effects\" rel=\"nofollow\" target=\"_blank\">https://angular.dev/guide/signals#effects</a></p>\n<p>Author's LinkedIn: <a href=\"https://www.linkedin.com/in/serhii-zhydetskyi-80a7789b/\" rel=\"nofollow\" target=\"_blank\">https://www.linkedin.com/in/serhii-zhydetskyi-80a7789b/</a></p>\n</body>\n</html>\n"},"__N_SSG":true}