<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>제품의 해부학 | issue-truck</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://issue-truck.github.io///post/2024-05-15-AnatomyOfAProduct" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="제품의 해부학 | issue-truck" data-gatsby-head="true"/><meta property="og:title" content="제품의 해부학 | issue-truck" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-AnatomyOfAProduct_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://issue-truck.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://issue-truck.github.io///post/2024-05-15-AnatomyOfAProduct" data-gatsby-head="true"/><meta name="twitter:title" content="제품의 해부학 | issue-truck" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-AnatomyOfAProduct_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | issue-truck" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 13:43" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a2564712101d0e30.js" defer=""></script><script src="/_next/static/j1jNlyrKP6vysiJTgEH8g/_buildManifest.js" defer=""></script><script src="/_next/static/j1jNlyrKP6vysiJTgEH8g/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Issue Truck</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">제품의 해부학</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="제품의 해부학" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Issue Truck</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-AnatomyOfAProduct&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-15-AnatomyOfAProduct_0.png"/>
<p>그래서 시니어/아키텍트/프로그래머 같은 역할이 궁금한거야?</p>
<p>아니면 제품이 개발되는 과정에서 10일마다 새로 작성할 필요가 없이 진행 상황을 살펴보고 싶은 건가? 어쨌든 넌 제자리에 있어.</p>
<p>이 기사는 코드 및 시스템을 설계하는 데 사용한 방법에 대한 설명으로, 제품 수명 동안 테스트 가능성, 변화 속도를 최대화하고 기술 부채를 줄이는 데 도움이 될 것이야. 이 기사는 https://mailgun.com에서 제품을 구축하고 확장하는 경험의 총결이야.</p>
<p>그래서 우리는 상상 속 제품을 디자인, 배포, 확장 및 예상치 못한 새로운 요구사항까지 따라갈 것입니다. 우리는 아주 많은 세부 사항을 건너뛰고 조금씩 뛰어다니겠지만, 좋은 코드 아키텍처가 제품 수명 동안 자산이 될 수 있는 전체적인 관점을 제공하는 것이 목표입니다.</p>
<p>준비되셨나요? 시작해 봅시다...</p>
<h1>메타 모델</h1>
<p>먼저 코드 아키텍처를 어떻게 정신적으로 모델링해야 하는지 고민해보겠습니다. 메타 모델은 우리가 정신 모델을 구성하는 추상화의 세부 사항을 이해할 필요없이 시스템 전체에 대해 추론할 수 있게 해줍니다. 여기서 제시하는 정신 모델은 Mailgun에서 코드와 아키텍처를 만들고 추론하는 데 성공적으로 사용되었습니다. 이 생각의 방식은 최대한의 유연성을 제공하고 기술적 부채를 피하고 관리하며 제품 수명 동안 높은 품질의 코드를 유지할 수 있도록 도와줍니다.</p>
<p>이 기사에서는 도메인 주도 설계, 추상화, 관심사 분리 및 데이터 소유권 원칙에 영감을 받은 접근법을 소개합니다. 이를 DACO(Domain, Abstract, Concern, Ownership)로 간략히 부르겠습니다. 이러한 원칙 대부분은 새로운 것이 아니며 수년 동안 존재해 왔습니다. 이러한 개념을 숙달하는 것은 좋은 코드와 좋은 아키텍처를 작성하는 데 극히 중요합니다.</p>
<p>이메일 전달 제품의 생성을 고려해 보겠습니다. 이제 이 기사의 나머지 부분에서는 데이터, 인터페이스 및 코드 변경이 제품 수명 주기 동안 어떻게 전개될 수 있는지 확인하기 위해 이 제품을 따라가 보겠습니다.</p>
<h1>전달 제품</h1>
<p>먼저 제품에 대한 간단한 CRUD 인터페이스를 고려해 보겠습니다. 이는 사용자가 이메일 전달 제품을 위해 전달 규칙을 생성하고 삭제하는 곳입니다.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_1.png" alt="AnatomyOfAProduct_1"/></p>
<p>우리는 제품의 가장 간단한 기능을 정의합니다. 이를 통해 다음과 같은 규칙을 생성할 수 있습니다. &quot;from@example.com으로 보낸 이메일을 받으면 이메일을 forward@email.com으로 전달합니다.&quot;</p>
<p>이제 이러한 규칙을 데이터베이스에 저장하고, 이 서비스 부분을 구성할 인터페이스를 모델링합니다.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_2.png" alt="AnatomyOfAProduct_2"/></p>
<p>우리의 인지 모델 안에 있는 첫 두 개의 인터페이스는 입력 및 출력의 추상화이기도 합니다. RuleStore는 우리가 사용하는 데이터베이스를 추상화하고 Repository 패턴의 예입니다. 두 번째 추상화는 HttpAPI입니다. HttpAPI를 서비스의 인터페이스로 생각하지 말고 RuleStore에 대한 네트워크 인터페이스로 생각할 수 있습니다. 이것은 주로 RuleStore 메소드를 네트워크에 노출시키는 기능을 하기 때문입니다.</p>
<p>그런데 왜 우리는 코드를 절차적으로 구성하지 않을까요? 이 인터페이스들은 서비스를 통해 데이터가 통과하는 과정에 실제로 일어나는 절차를 따르지 않는 것 같은데, 왜 이 프로젝트 초기에 이렇게 인터페이스를 사용하여 복잡하게 만들까요? 이러한 추상화가 왜 이렇게 중요한지 이해하기 위해, 데이터(우리의 데이터인 규칙)가 우리 시스템을 통해 어떻게 전달되는지를 엄격히 절차적인 관점에서 살펴보겠습니다. 새 규칙을 생성할 때 우리가 하는 일에 대한 시각화가 여기 있습니다.</p>
<p>Procedural 모델에서 사용자는 API에 따라 JSON 규칙을 작성하고 HTTP Post를 통해 보냅니다. 그런 다음 우리는 규칙을 유효성 검사합니다(즉, 이메일 주소가 올바른가?) 그리고 그것을 데이터베이스에 저장합니다.</p>
<p>HttpAPI 핸들러가 JSON rule을 받을 때, 구조체로 un-marshal하고 규칙을 유효성 검사한 후 데이터베이스에 저장하기 전에 정리해야 할 이유가 뭐죠? 이 작업을 두 가지 다른 인터페이스와 여러 메소드로 나눠서 사용하는 이유가 뭘까요?</p>
<p>이 절차적 논리는 심지어 HttpAPI 핸들러를 나쁜 데이터로부터 나머지 서비스를 보호하는 문지기로 생각한다면 직관적일 수도 있습니다. 그러나 여기서 제가 언급하고 싶은 두 번째 중요한 개념을 소개하고 싶습니다.</p>
<h1>데이터 소유권</h1>
<p>우리는 스스로에게 물어야 합니다. 규칙의 올바른 데이터를 갖는 책임은 누구일까요? 규칙은 누가 확보하고 있을까요? 누가 규칙과 데이터베이스를 남용으로부터 보호할까요? 이러한 질문의 연속은 정신적 모델을 구성할 때 중요합니다. 왜냐하면 누가 무엇을 소유하는지 명확히 한다면, 유효성 검사를 통합하고 데이터를 보호하는 작업을 하나의 위치에 집중시킬 수 있고 정신적 모델을 단순화할 수 있기 때문입니다. 소유권에 대한 이 아이디어는 데이터가 저장된 데이터베이스에서 쉼 상태에서 규칙을 소유하는 저장소 패턴과 잘 맞습니다. 또한 데이터의 측면을 소유하는 파이프라인과 함께 사용될 때, 데이터가 변환될 때 데이터의 소유권이 시스템의 다른 모듈로 넘어갈 수 있습니다.</p>
<p>그러나 HTTPAPI 인터페이스가 네트워크에서 데이터의 소유권을 가져오기 때문에 데이터는 일종의 직렬화 형식에서 코드 구조로 변환되기 때문에 데이터를 보유해야 한다는 주장도 할 수 있습니다. 그러나 데이터는 RuleStore로 향하는 길목에서 HttpAPI를 통과하기만 합니다. 어떤 면에서 HttpAPI는 데이터의 변환기일 뿐입니다. HttpAPI의 유일한 관심사는 HTTP를 통해 JSON으로 데이터를 가져 와 RuleStore가 이해할 수 있는 구조로 변환하는 것입니다. HttpAPI를 네트워크 어댑터로 생각할 수 있습니다. 이를 통해 HttpAPI와 RuleStore가 서비스 전반의 입력과 출력을 추상화하는 동시에 내부 모듈에 대한 추상화도 될 수 있음을 알 수 있습니다. 이러한 추상화를 기반으로 코드를 구축하면 API에 새로운 기능이 추가될 경우에 매우 유용할 수 있습니다.</p>
<p>그러나 KISS (Keep It Simple Stupid)에 따르면 작동하는 가장 간단한 것을 하라고 합니다. 그렇다면 /v1/forwards의 HTTP 핸들러에서 JSON을 해석하고 유효성을 검사하며 데이터를 데이터베이스에 저장하는 것이 최선일 것입니다. 이 인터페이스와 소유권 문제가 뭐지?</p>
<p>설명을 하자면, 우리가 어떻게 이러한 인터페이스/추상화가 장기적으로 어떻게 우리에게 이익을 가져다주는지 살펴봄으로써 전방 프로젝트의 수명주기를 계속해보겠습니다.</p>
<p>제품 디자인으로 다시 돌아와서, 우리가 규칙 저장소가 규칙을 소유하기로 결정했기 때문에 데이터베이스에 저장하기 전에 규칙을 유효성 검사해야 합니다. 우리는 규칙이 데이터가 부족하거나 잘못되었을 때 데이터베이스를 보호하기 위해 &quot;보호&quot;한다고 말합니다. 소유권을 반영하기 위해 다이어그램을 업데이트해보겠습니다.</p>
<img src="/assets/img/2024-05-15-AnatomyOfAProduct_4.png"/>
<p>저희 제품의 다음 주요 부분은 고객이 이메일을 전달하기 위한 인터페이스를 제공하는 것입니다. 이메일을 받고 저장하며 규칙과 일치하는 이메일을 전달할 SMTP 서버가 필요합니다. 이게 어떻게 보일지 다이어그램으로 살펴봅시다.</p>
<img src="/assets/img/2024-05-15-AnatomyOfAProduct_5.png"/>
<p>여기서도 SmtpServer를 통해 응용 프로그램 입력을 추상화하고, 그 이메일을 MIME 형식으로 저장하는 EmailStore가 있습니다. 다음으로는 이메일 전달 규칙을 찾은 RuleStore에 일치하는지 여부를 판단하는 ForwardEvaluator가 있습니다. 이메일이 일치한다면 이메일을 전달하는 데 사용하는 SmtpClient 출력 추상화를 사용하여 EmailStore를 이용하여 저장된 이메일을 검색하고 대상 SMTP 서버로 보냅니다.</p>
<h1>데이터</h1>
<p>우리 제품의 주요 데이터 형식은 Rule과 Email 두 가지가 있어요. Rule은 변환 기준을 제공하고, Email은 우리가 변환하는 대상입니다. 우리는 To 주소를 MIME에서 변경하는 것이므로 &quot;변환&quot;이라 말해요. 우리는 우아한 이메일 수신자로서, MIME에 대신 받은 헤더를 추가한 후 Email을 적합한 SMTP 서버에 전달해요.</p>
<p>SMTP를 통해 이메일을 받으면, SMTP 프로토콜을 통해 제공되는 수신자(To)와 발신자(From) 정보를 받게 되고, 그 후에 이메일의 본문 또는 MIME을 받게 됩니다. 우리는 MIME(여러 메가바이트의 데이터가 될 수 있어요)를 EmailStore에 전달하여 Email 데이터베이스에 유지하게 합니다. EmailStore는 이메일 ID를 생성하고, 이후에는 EmailStore에서 이메일을 검색하는 데 사용됩니다.</p>
<p>SMTP 서버가 이메일을 받으면, 이메일의 본문(MIME)과 수신자와 발신자와 같은 이메일에 대한 몇 가지 메타데이터를 받습니다. 이 데이터를 다음 구조로 나타냅니다.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_6.png" alt="이미지"/></p>
<p>이 메타데이터 구조는 이메일이 데이터베이스의 규칙과 일치하는지 여부를 결정하기 위해 ForwardEvaluator에 전달되는 것입니다.</p>
<h1>제품 출시</h1>
<p>현재, 우리는 최소한이지만 완벽한 이메일 전달 제품을 갖고 있습니다. 제품을 출시하고 나서 우리 고객들이 행복하며 우리는 축하로 브리스킷을 구웁니다. (저는 텍사스에 살고 있으니, 이것이 우리가 하는 일입니다)</p>
<p>제품을 발표한 직후에 규칙 일치 및 전송이 새 이메일 메시지를 받는 능력을 늦추고 있다는 것을 알게 되었습니다. 이를 따라가기 위해 규칙 처리와 SMTP 전달을 수평 확장해야 합니다. 두 개의 스레드 풀을 구현해 보겠습니다. 첫 번째는 규칙을 병렬로 처리할 수 있는 ForwardEvaluator 스레드 풀입니다. 그 다음으로, 메시지 전달을 처리할 SmtpClients 스레드 풀을 생성합니다.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_7.png" alt="image"/></p>
<p>워커 풀에 작업을 대기시키기 위해 큐(고랭채널)를 사용합니다. ForwardEvaluator 풀은 이메일 메타데이터를 입력으로 받습니다(전달 이메일 주소와 일치시키기 위해 사용되는 발신 및 수신 헤더가 포함됨). 그런 다음 일치가 발생하면 ForwardEvaluator가 SmtpClient 워커 풀의 워커를 통해 전달을 위해 Queue(SmtpJob)를 호출합니다.</p>
<p>이를 실행하기 위해 실제로 변경된 코드가 매우 적다는 점이 흥미롭습니다. 이미 각 문제 영역 주변에 인터페이스가 있었기 때문에 대부분의 코드가 추가적입니다. 간단하게 인터페이스를 워커 풀에 넣었을 뿐인데 이제 서버가 허용하는 대로 CPU 수를 확장할 수 있습니다. 그러나 계속 진행하고 제품이 성장함에 따라 이러한 인터페이스가 어떻게 도움이 되는지 계속 살펴보겠습니다.</p>
<p>이제 6개월이 지난 지금은 점점 더 큰 고객을 유치하고 있어요. 어떤 고객들은 60,000부터 100,000개의 이메일 주소를 전달하고 싶어해요. 그리고 기술을 잘 모르시는 다른 고객들은 대량으로 이메일 주소를 가져오기를 요청하고 있어요. 그래서 우리는 CSV 업로드 엔드포인트를 추가하기로 결정했어요.</p>
<p>우리의 모델을 업데이트해서 현재 디자인과 어떻게 맞아 떨어지는지 살펴봐요.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_8.png" alt="이미지"/></p>
<p>여기에서 핵심 제품에는 크게 변화가 없고, 검증이 RuleStore에서 발생하기 때문에 CsvImporter에 중복된 검증 코드가 없다는 게죠—이렇게 동작하는 것을 보세요?</p>
<p>단순히 새로운 입력 추상화를 추가하고 HTTP를 통한 CSV 가져오기를 처리하고 있습니다. 우리는 소유권과 입출력 인터페이스를 정확하게 식별했기 때문에 이 새로운 기능 변경은 현재 코드를 리팩토링할 필요가 없습니다. 새로운 문제 도메인을 위한 새로운 추상화와 HttpAPI에 대한 새로운 핸들러만 추가하면 됩니다.</p>
<p>여기서 우리는 소유권이 작용하는 것을 볼 수 있습니다. CsvImporter는 CSV 파일(데이터)을 업로드할 때 해당 CSV 파일의 소유권을 가지고, 그 CSV 파일을 규칙으로 변환한 후에 그 규칙을 RuleStore에 저장합니다. 이것은 시스템을 흐르는 데이터이며, 변환되는 데이터의 소유권이 데이터의 변환이 발생한 후에 전달되는 것입니다. 각각의 그 소유권 이전과 변환은 별도의 문제 도메인이므로 하나의 문제 도메인에 여러 변환을 과중하게 부담시키지 않습니다.</p>
<p>당신이 생산 라인의 비유를 사용하고 싶다면, 각 변환이 생산 라인 위의 각 정거장이라는 것을 생각해보세요. 각 정거장에서는 다음 정거장으로 이동하기 전에 자동차(또는 우리 경우 데이터)에 대해 무언가를 추가하거나 변경합니다. 이렇게 함으로써, 우리는 우리의 인지 부하와 코드를 간단하게 만듭니다.</p>
<p>#成長의 고통</p>
<p>새로운 CSV 가져오기 기능이 추가되었고, 대형 고객이 추가되면서, 저희의 전달 제품은 성공의 압박을 느끼기 시작했습니다. 처리 시간이 늘어나서 계속 확장하고자 한다면 성능을 개선해야 합니다. 저희의 지표에 따르면 RulesStore가 HttpAPI와 ForwardEvaluator 양쪽에서 일치하는 규칙을 찾을 때 고전을 겪고 있습니다. 캐시를 추가할 시간인데, 어디에 넣어야 할까요? 데이터 소유 정신 모델에 따라 캐시는 규칙 저장소와 함께 있어야 합니다. RuleStore가 데이터와 데이터베이스를 소유하고 보호하기 때문입니다. 게다가 RuleStore 추상화는 캐시가 언제 무효화되어야 하는지 알고 있으며 규칙이 삭제되거나 업데이트될 때 캐시를 무효화할 수 있습니다. HttpAPI와 ForwardEvaluator는 캐시에서 직접적으로 알거나 접근하지 않아도 성능 개선을 활용할 수 있습니다.</p>
<p>여기에서는 RuleStore 인터페이스를 추상화하고 RuleStore 앞에 캐시를 놓았습니다. 캐시를 RuleStore 내부에 캡슐화하는 것도 완전히 유효하지만, 이러한 방식으로 구현하는 것에는 몇 가지 장점이 있습니다. 첫째, 이 분리는 코드 변경 없이 인메모리 캐시에서 memcached나 redis로 캐시 구현을 변경할 수 있게 합니다. 둘째, 이는 Groupcache를 사용하여 캐시 요청을 응용 프로그램의 다른 인스턴스로 전달하고 RuleStore 작업을 수행하도록 할 수 있어서, 그룹 문제를 피할 수 있는 특수한 기능을 수행할 수 있습니다. 이러한 두 가지 이점 외에도 캐시 코드와 데이터베이스 코드의 분리로 인해 한 쪽을 변경하더라도 다른 쪽에 영향을 미치지 않게 됩니다.</p>
<p>하지만 또 다른 문제점을 알아차렸습니다. 일부 고객 또는 인터넷에 있는 악의적인 사용자들이 SMTP 서버를 남용하기 시작했습니다! 매 초 수백 메가바이트의 데이터를 보내고 EmailStore를 압도하고 있습니다. EmailStore를 남용으로부터 보호해야 합니다! 전통적인 지혜라면 SMTP 서버를 통해 고객이 보낼 수 있는 바이트 수를 제한해야 한다고 할 것입니다. 그러나 데이터 소유 관점에서 생각한다면 EmailStore가 데이터를 소유하는만큼 데이터를 남용으로부터 보호해야 하는 것이 맞지 않을까요?</p>
<p>SMTP 서버는 데이터 전송을 느리게 만들 수 있고 해야 합니다. 그러나 이는 이메일 스토어가 압도되고 있다고 표시될 때에만 이루어집니다. 데이터 전송 속도 제한 결정은 네트워크로부터 이메일 스토어를 추상화하는 인터페이스(SmtpServer라고 함)가 아니라 이메일 스토어로부터 나와야 합니다. 만약 이 결정에 대해 헷갈리신다면 계속 읽어보시면 그 의미가 분명해질 것입니다.</p>
<h1>성공의 대가</h1>
<p>이제 우리 제품이 매우 성공적이어서 더 큰 이메일 처리 회사에 인수되고 있습니다! 그러나 새로운 모회사는 내부 간 서비스 통신을 위해 모든것을 GRPC로 결정했고, 그들은 우리의 포워딩 제품이 우리의 SMTP 서버와 그들의 SMTP 서버에서 온 이메일 모두를 지원하길 원합니다. 그러나 그들의 SMTP 서버는 GRPC를 통해 이메일을 보낼 것이라고 하죠!?!?! 이 모든 것이 어떻게 우리의 사고 모델을 다시 한 번 바꾸는지 보겠습니다.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_10.png" alt="이미지"/></p>
<p>SMTP 및 GRPC를 통해 이메일을 수락하기 시작했다는 사실을 알 수 있습니다. 두 인터페이스 모두 EmailStore에 구현된 속도 제한의 이점을 누립니다. 따라서 두 인터페이스가 많은 이메일을 받는 경우에도 EmailStore가 데이터베이스가 넘어가는 것을 방지할 수 있습니다. 게다가, EmailStore에 메트릭을 추가하여 데이터 저장소를 확장해야 하는 시기를 정확히 파악할 수 있습니다.</p>
<p>데이터베이스를 보호하는 또 다른 자주 간과되는 이점은 내부 남용 외에도 외부 남용에서 제공됩니다. 몇 년 전에 파이썬에서 ORM을 사용하는 시스템에서 일했었는데요. 이런 경우에는 상호 작용하는 객체가 메모리 내의 객체인지 데이터베이스의 테이블을 나타내는지를 판별하는 것이 어려운 경우가 많습니다. 그래서 새 기능을 구현할 때 이 객체의 모든 항목을 기쁘게 반복했지만 해당 객체가 데이터베이스로 N+1개의 선택을 보내는 ORM 객체임을 깨달지 못했습니다. 이 기능은 테스트에서 완벽하게 수행되었고 스테이징에서도 잘 실행되었지만 배포하자마자 생산 데이터베이스를 다운시켰습니다.</p>
<p>이와 같은 종류의 남용에 대한 생산 데이터베이스 보호가 제공되었다면 우리는 의도치 않은 데이터베이스 장애 대신 응용 프로그램 성능 저하를 경험했을 것입니다.</p>
<h1>데이터베이스 전환</h1>
<p>과부하된 데이터베이스에 대해 얘기하자면, 저희는 본사의 SMTP 서버와 통합된 이후에 이메일이 EmailStore에 저장되는 양이 거의 두 배로 증가했고 이로 인해 기존 데이터베이스가 스트레스를 받고 있습니다.</p>
<p>다행히도 새로운 본사와의 계약을 통해 클라우드 제공업체의 클라우드 파일 저장 제품에 대한 매우 좋은 협상을 이루었는데, 그들은 우리에게 이메일을 그곳에 저장하길 원합니다. EmailStore 인터페이스가 좋아서 데이터베이스에서 이메일을 저장하고 검색하는 것에서 새로운 파일 저장 제품으로 전환할 수 있습니다.</p>
<p>하지만 잠깐, 어떻게 하면 구름 저장소로 이전된 그 모든 이메일들을 마이그레이션할 수 있을까요. 그것은 정말 많은 양의 데이터입니다. 이메일 중에는 20-50MB 크기인 것도 있습니다! 게다가 고객들은 이전하는 동안에도 수용 가능한 서비스를 기대하고 있습니다! 이 문제를 해결하기 위해, EmailStore 인터페이스로 CloudEmailStore를 구현하고 이전 EmailStore를 OldEmailStore로 이름을 변경합니다. 이제 무엇인가를 찾을 때 옛날 이메일을 찾을 때 OldEmailStore를 호출하고 새로운 이메일을 저장할 때 CloudEmailStore를 호출하는 EmailStoreAdaptor라는 동일한 인터페이스를 구현하는 어댑터를 만듭니다. 그런 다음 이메일을 &quot;마이그레이션된&quot; 것으로 표시하는 비동기 마이그레이션 프로세스를 개발하여, 이메일Store 어댑터 인터페이스에게 이미 CloudEmailStore로 마이그레이션된 이메일을 알리고 그곳에서 찾도록 알려줍니다.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_11.png" alt="AnatomyOfAProduct_11"/></p>
<p>이주가 완료된 후에는 EmailStoreMigration 어댑터를 제거하고 CloudEmailStore 구현이 새로운 EmailStore가 됩니다.</p>
<h1>기적을 일으키는 일꾼</h1>
<p>음…… 루틴 유지보수 변경이 ForwardEvaluator에 버그를 도입했는데요. 결과적으로 지난 24시간 동안 이메일을 전달하지 않았습니다!</p>
<p>하지만 모든 게 아득하지는 않습니다. SmtpServer의 훌륭한 감사 로그 덕분에 그 날 받은 모든 이메일의 이메일 ID를 알고 있습니다. 우리가 ForwardEvaluator와 EmailStore를 시스템의 나머지 부분과 추상화했기 때문에 새로운 GRPC 메소드인 ReprocessEmail()를 신속하게 작성하여 사용하여 그 날 받은 모든 이메일 ID를 입력으로 사용하고 재처리할 수 있습니다. 이는 SMTPServer가 모든 받은 이메일을 EmailStore에 저장했기 때문에 작동합니다. 이로써 지난 24시간 동안 받은 모든 이메일 ID의 감사 로그와 함께 재처리하고 전달할 수 있습니다! 이는 다음과 같이 보입니다.</p>
<p><img src="/assets/img/2024-05-15-AnatomyOfAProduct_12.png" alt="이미지"/></p>
<p>이제 남은 것은 오늘 받은 이메일 ID를 감사 로그에서 읽어와 ReprocessEmail()를 호출하여 가능한 전달 여부를 평가하는 외부 프로세스를 작성하는 것이 있습니다. 위기가 회피되었어요!</p>
<p>데이터베이스 쿼리 조합이나 일회성으로 테스트되지 않은 코드 조각을 접속해 모든 처리를 수행하는 대신, 우리는 기존의 코드를 그대로 사용하고 있습니다. 문제 영역별로 잘 정의된 추상화를 활용하고 있으며, 실제 운영에서 충분히 이해하고 테스트한 것을 통해 잘 구성되었습니다. 이 일을 처리하기 위해 우리가 작성한 유일한 새로운 코드는 GRPC 메소드 ReprocessEmail()와 감사 로그를 읽고 ReprocessEmail()를 호출하는 스크립트에 있었습니다.</p>
<p>기존 인터페이스를 재사용함으로써 우리의 재처리 전략이 작동할 것에 대한 큰 신뢰를 얻었습니다. 만약 처음부터 KISS 원칙을 적용하지 않고 도메인 주도 인터페이스를 정의하고 문제를 분리하고 시스템 전반에 데이터 소유권을 할당하는 데 시간을 들이지 않았다면 이것이 가능하지 않았을 겁니다. 축하합니다, 이제 당신은 사무실에서 &quot;기적을 행하는 사람&quot;의 호칭을 지닐 수 있습니다. 마음껏 드세요.</p>
<h1>새 버전 소개</h1>
<p>이제 곧 포워딩 제품의 새 버전을 소개할 예정입니다. 그러나 이 게시물이 원래 계획했던 것보다 훨씬 길어졌기 때문에 별도의 게시물로 나누어서 소개할 예정입니다.</p>
<p>다음 게시물은 다음 주에 Medium에서 확인하실 수 있습니다!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"제품의 해부학","description":"","date":"2024-05-15 13:43","slug":"2024-05-15-AnatomyOfAProduct","content":"\n\u003cimg src=\"/assets/img/2024-05-15-AnatomyOfAProduct_0.png\" /\u003e\n\n그래서 시니어/아키텍트/프로그래머 같은 역할이 궁금한거야?\n\n아니면 제품이 개발되는 과정에서 10일마다 새로 작성할 필요가 없이 진행 상황을 살펴보고 싶은 건가? 어쨌든 넌 제자리에 있어.\n\n이 기사는 코드 및 시스템을 설계하는 데 사용한 방법에 대한 설명으로, 제품 수명 동안 테스트 가능성, 변화 속도를 최대화하고 기술 부채를 줄이는 데 도움이 될 것이야. 이 기사는 https://mailgun.com에서 제품을 구축하고 확장하는 경험의 총결이야.\n\n그래서 우리는 상상 속 제품을 디자인, 배포, 확장 및 예상치 못한 새로운 요구사항까지 따라갈 것입니다. 우리는 아주 많은 세부 사항을 건너뛰고 조금씩 뛰어다니겠지만, 좋은 코드 아키텍처가 제품 수명 동안 자산이 될 수 있는 전체적인 관점을 제공하는 것이 목표입니다.\n\n준비되셨나요? 시작해 봅시다...\n\n# 메타 모델\n\n먼저 코드 아키텍처를 어떻게 정신적으로 모델링해야 하는지 고민해보겠습니다. 메타 모델은 우리가 정신 모델을 구성하는 추상화의 세부 사항을 이해할 필요없이 시스템 전체에 대해 추론할 수 있게 해줍니다. 여기서 제시하는 정신 모델은 Mailgun에서 코드와 아키텍처를 만들고 추론하는 데 성공적으로 사용되었습니다. 이 생각의 방식은 최대한의 유연성을 제공하고 기술적 부채를 피하고 관리하며 제품 수명 동안 높은 품질의 코드를 유지할 수 있도록 도와줍니다.\n\n이 기사에서는 도메인 주도 설계, 추상화, 관심사 분리 및 데이터 소유권 원칙에 영감을 받은 접근법을 소개합니다. 이를 DACO(Domain, Abstract, Concern, Ownership)로 간략히 부르겠습니다. 이러한 원칙 대부분은 새로운 것이 아니며 수년 동안 존재해 왔습니다. 이러한 개념을 숙달하는 것은 좋은 코드와 좋은 아키텍처를 작성하는 데 극히 중요합니다.\n\n이메일 전달 제품의 생성을 고려해 보겠습니다. 이제 이 기사의 나머지 부분에서는 데이터, 인터페이스 및 코드 변경이 제품 수명 주기 동안 어떻게 전개될 수 있는지 확인하기 위해 이 제품을 따라가 보겠습니다.\n\n# 전달 제품\n\n먼저 제품에 대한 간단한 CRUD 인터페이스를 고려해 보겠습니다. 이는 사용자가 이메일 전달 제품을 위해 전달 규칙을 생성하고 삭제하는 곳입니다.\n\n![AnatomyOfAProduct_1](/assets/img/2024-05-15-AnatomyOfAProduct_1.png)\n\n우리는 제품의 가장 간단한 기능을 정의합니다. 이를 통해 다음과 같은 규칙을 생성할 수 있습니다. \"from@example.com으로 보낸 이메일을 받으면 이메일을 forward@email.com으로 전달합니다.\"\n\n이제 이러한 규칙을 데이터베이스에 저장하고, 이 서비스 부분을 구성할 인터페이스를 모델링합니다.\n\n![AnatomyOfAProduct_2](/assets/img/2024-05-15-AnatomyOfAProduct_2.png)\n\n우리의 인지 모델 안에 있는 첫 두 개의 인터페이스는 입력 및 출력의 추상화이기도 합니다. RuleStore는 우리가 사용하는 데이터베이스를 추상화하고 Repository 패턴의 예입니다. 두 번째 추상화는 HttpAPI입니다. HttpAPI를 서비스의 인터페이스로 생각하지 말고 RuleStore에 대한 네트워크 인터페이스로 생각할 수 있습니다. 이것은 주로 RuleStore 메소드를 네트워크에 노출시키는 기능을 하기 때문입니다.\n\n그런데 왜 우리는 코드를 절차적으로 구성하지 않을까요? 이 인터페이스들은 서비스를 통해 데이터가 통과하는 과정에 실제로 일어나는 절차를 따르지 않는 것 같은데, 왜 이 프로젝트 초기에 이렇게 인터페이스를 사용하여 복잡하게 만들까요? 이러한 추상화가 왜 이렇게 중요한지 이해하기 위해, 데이터(우리의 데이터인 규칙)가 우리 시스템을 통해 어떻게 전달되는지를 엄격히 절차적인 관점에서 살펴보겠습니다. 새 규칙을 생성할 때 우리가 하는 일에 대한 시각화가 여기 있습니다.\n\nProcedural 모델에서 사용자는 API에 따라 JSON 규칙을 작성하고 HTTP Post를 통해 보냅니다. 그런 다음 우리는 규칙을 유효성 검사합니다(즉, 이메일 주소가 올바른가?) 그리고 그것을 데이터베이스에 저장합니다.\n\nHttpAPI 핸들러가 JSON rule을 받을 때, 구조체로 un-marshal하고 규칙을 유효성 검사한 후 데이터베이스에 저장하기 전에 정리해야 할 이유가 뭐죠? 이 작업을 두 가지 다른 인터페이스와 여러 메소드로 나눠서 사용하는 이유가 뭘까요?\n\n이 절차적 논리는 심지어 HttpAPI 핸들러를 나쁜 데이터로부터 나머지 서비스를 보호하는 문지기로 생각한다면 직관적일 수도 있습니다. 그러나 여기서 제가 언급하고 싶은 두 번째 중요한 개념을 소개하고 싶습니다.\n\n# 데이터 소유권\n\n우리는 스스로에게 물어야 합니다. 규칙의 올바른 데이터를 갖는 책임은 누구일까요? 규칙은 누가 확보하고 있을까요? 누가 규칙과 데이터베이스를 남용으로부터 보호할까요? 이러한 질문의 연속은 정신적 모델을 구성할 때 중요합니다. 왜냐하면 누가 무엇을 소유하는지 명확히 한다면, 유효성 검사를 통합하고 데이터를 보호하는 작업을 하나의 위치에 집중시킬 수 있고 정신적 모델을 단순화할 수 있기 때문입니다. 소유권에 대한 이 아이디어는 데이터가 저장된 데이터베이스에서 쉼 상태에서 규칙을 소유하는 저장소 패턴과 잘 맞습니다. 또한 데이터의 측면을 소유하는 파이프라인과 함께 사용될 때, 데이터가 변환될 때 데이터의 소유권이 시스템의 다른 모듈로 넘어갈 수 있습니다.\n\n그러나 HTTPAPI 인터페이스가 네트워크에서 데이터의 소유권을 가져오기 때문에 데이터는 일종의 직렬화 형식에서 코드 구조로 변환되기 때문에 데이터를 보유해야 한다는 주장도 할 수 있습니다. 그러나 데이터는 RuleStore로 향하는 길목에서 HttpAPI를 통과하기만 합니다. 어떤 면에서 HttpAPI는 데이터의 변환기일 뿐입니다. HttpAPI의 유일한 관심사는 HTTP를 통해 JSON으로 데이터를 가져 와 RuleStore가 이해할 수 있는 구조로 변환하는 것입니다. HttpAPI를 네트워크 어댑터로 생각할 수 있습니다. 이를 통해 HttpAPI와 RuleStore가 서비스 전반의 입력과 출력을 추상화하는 동시에 내부 모듈에 대한 추상화도 될 수 있음을 알 수 있습니다. 이러한 추상화를 기반으로 코드를 구축하면 API에 새로운 기능이 추가될 경우에 매우 유용할 수 있습니다.\n\n그러나 KISS (Keep It Simple Stupid)에 따르면 작동하는 가장 간단한 것을 하라고 합니다. 그렇다면 /v1/forwards의 HTTP 핸들러에서 JSON을 해석하고 유효성을 검사하며 데이터를 데이터베이스에 저장하는 것이 최선일 것입니다. 이 인터페이스와 소유권 문제가 뭐지?\n\n설명을 하자면, 우리가 어떻게 이러한 인터페이스/추상화가 장기적으로 어떻게 우리에게 이익을 가져다주는지 살펴봄으로써 전방 프로젝트의 수명주기를 계속해보겠습니다.\n\n제품 디자인으로 다시 돌아와서, 우리가 규칙 저장소가 규칙을 소유하기로 결정했기 때문에 데이터베이스에 저장하기 전에 규칙을 유효성 검사해야 합니다. 우리는 규칙이 데이터가 부족하거나 잘못되었을 때 데이터베이스를 보호하기 위해 \"보호\"한다고 말합니다. 소유권을 반영하기 위해 다이어그램을 업데이트해보겠습니다.\n\n\u003cimg src=\"/assets/img/2024-05-15-AnatomyOfAProduct_4.png\" /\u003e\n\n저희 제품의 다음 주요 부분은 고객이 이메일을 전달하기 위한 인터페이스를 제공하는 것입니다. 이메일을 받고 저장하며 규칙과 일치하는 이메일을 전달할 SMTP 서버가 필요합니다. 이게 어떻게 보일지 다이어그램으로 살펴봅시다.\n\n\u003cimg src=\"/assets/img/2024-05-15-AnatomyOfAProduct_5.png\" /\u003e\n\n여기서도 SmtpServer를 통해 응용 프로그램 입력을 추상화하고, 그 이메일을 MIME 형식으로 저장하는 EmailStore가 있습니다. 다음으로는 이메일 전달 규칙을 찾은 RuleStore에 일치하는지 여부를 판단하는 ForwardEvaluator가 있습니다. 이메일이 일치한다면 이메일을 전달하는 데 사용하는 SmtpClient 출력 추상화를 사용하여 EmailStore를 이용하여 저장된 이메일을 검색하고 대상 SMTP 서버로 보냅니다.\n\n# 데이터\n\n우리 제품의 주요 데이터 형식은 Rule과 Email 두 가지가 있어요. Rule은 변환 기준을 제공하고, Email은 우리가 변환하는 대상입니다. 우리는 To 주소를 MIME에서 변경하는 것이므로 \"변환\"이라 말해요. 우리는 우아한 이메일 수신자로서, MIME에 대신 받은 헤더를 추가한 후 Email을 적합한 SMTP 서버에 전달해요.\n\nSMTP를 통해 이메일을 받으면, SMTP 프로토콜을 통해 제공되는 수신자(To)와 발신자(From) 정보를 받게 되고, 그 후에 이메일의 본문 또는 MIME을 받게 됩니다. 우리는 MIME(여러 메가바이트의 데이터가 될 수 있어요)를 EmailStore에 전달하여 Email 데이터베이스에 유지하게 합니다. EmailStore는 이메일 ID를 생성하고, 이후에는 EmailStore에서 이메일을 검색하는 데 사용됩니다.\n\nSMTP 서버가 이메일을 받으면, 이메일의 본문(MIME)과 수신자와 발신자와 같은 이메일에 대한 몇 가지 메타데이터를 받습니다. 이 데이터를 다음 구조로 나타냅니다.\n\n![이미지](/assets/img/2024-05-15-AnatomyOfAProduct_6.png)\n\n이 메타데이터 구조는 이메일이 데이터베이스의 규칙과 일치하는지 여부를 결정하기 위해 ForwardEvaluator에 전달되는 것입니다.\n\n# 제품 출시\n\n현재, 우리는 최소한이지만 완벽한 이메일 전달 제품을 갖고 있습니다. 제품을 출시하고 나서 우리 고객들이 행복하며 우리는 축하로 브리스킷을 구웁니다. (저는 텍사스에 살고 있으니, 이것이 우리가 하는 일입니다)\n\n제품을 발표한 직후에 규칙 일치 및 전송이 새 이메일 메시지를 받는 능력을 늦추고 있다는 것을 알게 되었습니다. 이를 따라가기 위해 규칙 처리와 SMTP 전달을 수평 확장해야 합니다. 두 개의 스레드 풀을 구현해 보겠습니다. 첫 번째는 규칙을 병렬로 처리할 수 있는 ForwardEvaluator 스레드 풀입니다. 그 다음으로, 메시지 전달을 처리할 SmtpClients 스레드 풀을 생성합니다.\n\n![image](/assets/img/2024-05-15-AnatomyOfAProduct_7.png)\n\n워커 풀에 작업을 대기시키기 위해 큐(고랭채널)를 사용합니다. ForwardEvaluator 풀은 이메일 메타데이터를 입력으로 받습니다(전달 이메일 주소와 일치시키기 위해 사용되는 발신 및 수신 헤더가 포함됨). 그런 다음 일치가 발생하면 ForwardEvaluator가 SmtpClient 워커 풀의 워커를 통해 전달을 위해 Queue(SmtpJob)를 호출합니다.\n\n이를 실행하기 위해 실제로 변경된 코드가 매우 적다는 점이 흥미롭습니다. 이미 각 문제 영역 주변에 인터페이스가 있었기 때문에 대부분의 코드가 추가적입니다. 간단하게 인터페이스를 워커 풀에 넣었을 뿐인데 이제 서버가 허용하는 대로 CPU 수를 확장할 수 있습니다. 그러나 계속 진행하고 제품이 성장함에 따라 이러한 인터페이스가 어떻게 도움이 되는지 계속 살펴보겠습니다.\n\n이제 6개월이 지난 지금은 점점 더 큰 고객을 유치하고 있어요. 어떤 고객들은 60,000부터 100,000개의 이메일 주소를 전달하고 싶어해요. 그리고 기술을 잘 모르시는 다른 고객들은 대량으로 이메일 주소를 가져오기를 요청하고 있어요. 그래서 우리는 CSV 업로드 엔드포인트를 추가하기로 결정했어요.\n\n우리의 모델을 업데이트해서 현재 디자인과 어떻게 맞아 떨어지는지 살펴봐요.\n\n![이미지](/assets/img/2024-05-15-AnatomyOfAProduct_8.png)\n\n여기에서 핵심 제품에는 크게 변화가 없고, 검증이 RuleStore에서 발생하기 때문에 CsvImporter에 중복된 검증 코드가 없다는 게죠—이렇게 동작하는 것을 보세요?\n\n단순히 새로운 입력 추상화를 추가하고 HTTP를 통한 CSV 가져오기를 처리하고 있습니다. 우리는 소유권과 입출력 인터페이스를 정확하게 식별했기 때문에 이 새로운 기능 변경은 현재 코드를 리팩토링할 필요가 없습니다. 새로운 문제 도메인을 위한 새로운 추상화와 HttpAPI에 대한 새로운 핸들러만 추가하면 됩니다.\n\n여기서 우리는 소유권이 작용하는 것을 볼 수 있습니다. CsvImporter는 CSV 파일(데이터)을 업로드할 때 해당 CSV 파일의 소유권을 가지고, 그 CSV 파일을 규칙으로 변환한 후에 그 규칙을 RuleStore에 저장합니다. 이것은 시스템을 흐르는 데이터이며, 변환되는 데이터의 소유권이 데이터의 변환이 발생한 후에 전달되는 것입니다. 각각의 그 소유권 이전과 변환은 별도의 문제 도메인이므로 하나의 문제 도메인에 여러 변환을 과중하게 부담시키지 않습니다.\n\n당신이 생산 라인의 비유를 사용하고 싶다면, 각 변환이 생산 라인 위의 각 정거장이라는 것을 생각해보세요. 각 정거장에서는 다음 정거장으로 이동하기 전에 자동차(또는 우리 경우 데이터)에 대해 무언가를 추가하거나 변경합니다. 이렇게 함으로써, 우리는 우리의 인지 부하와 코드를 간단하게 만듭니다.\n\n#成長의 고통\n\n새로운 CSV 가져오기 기능이 추가되었고, 대형 고객이 추가되면서, 저희의 전달 제품은 성공의 압박을 느끼기 시작했습니다. 처리 시간이 늘어나서 계속 확장하고자 한다면 성능을 개선해야 합니다. 저희의 지표에 따르면 RulesStore가 HttpAPI와 ForwardEvaluator 양쪽에서 일치하는 규칙을 찾을 때 고전을 겪고 있습니다. 캐시를 추가할 시간인데, 어디에 넣어야 할까요? 데이터 소유 정신 모델에 따라 캐시는 규칙 저장소와 함께 있어야 합니다. RuleStore가 데이터와 데이터베이스를 소유하고 보호하기 때문입니다. 게다가 RuleStore 추상화는 캐시가 언제 무효화되어야 하는지 알고 있으며 규칙이 삭제되거나 업데이트될 때 캐시를 무효화할 수 있습니다. HttpAPI와 ForwardEvaluator는 캐시에서 직접적으로 알거나 접근하지 않아도 성능 개선을 활용할 수 있습니다.\n\n여기에서는 RuleStore 인터페이스를 추상화하고 RuleStore 앞에 캐시를 놓았습니다. 캐시를 RuleStore 내부에 캡슐화하는 것도 완전히 유효하지만, 이러한 방식으로 구현하는 것에는 몇 가지 장점이 있습니다. 첫째, 이 분리는 코드 변경 없이 인메모리 캐시에서 memcached나 redis로 캐시 구현을 변경할 수 있게 합니다. 둘째, 이는 Groupcache를 사용하여 캐시 요청을 응용 프로그램의 다른 인스턴스로 전달하고 RuleStore 작업을 수행하도록 할 수 있어서, 그룹 문제를 피할 수 있는 특수한 기능을 수행할 수 있습니다. 이러한 두 가지 이점 외에도 캐시 코드와 데이터베이스 코드의 분리로 인해 한 쪽을 변경하더라도 다른 쪽에 영향을 미치지 않게 됩니다.\n\n하지만 또 다른 문제점을 알아차렸습니다. 일부 고객 또는 인터넷에 있는 악의적인 사용자들이 SMTP 서버를 남용하기 시작했습니다! 매 초 수백 메가바이트의 데이터를 보내고 EmailStore를 압도하고 있습니다. EmailStore를 남용으로부터 보호해야 합니다! 전통적인 지혜라면 SMTP 서버를 통해 고객이 보낼 수 있는 바이트 수를 제한해야 한다고 할 것입니다. 그러나 데이터 소유 관점에서 생각한다면 EmailStore가 데이터를 소유하는만큼 데이터를 남용으로부터 보호해야 하는 것이 맞지 않을까요?\n\nSMTP 서버는 데이터 전송을 느리게 만들 수 있고 해야 합니다. 그러나 이는 이메일 스토어가 압도되고 있다고 표시될 때에만 이루어집니다. 데이터 전송 속도 제한 결정은 네트워크로부터 이메일 스토어를 추상화하는 인터페이스(SmtpServer라고 함)가 아니라 이메일 스토어로부터 나와야 합니다. 만약 이 결정에 대해 헷갈리신다면 계속 읽어보시면 그 의미가 분명해질 것입니다.\n\n# 성공의 대가\n\n이제 우리 제품이 매우 성공적이어서 더 큰 이메일 처리 회사에 인수되고 있습니다! 그러나 새로운 모회사는 내부 간 서비스 통신을 위해 모든것을 GRPC로 결정했고, 그들은 우리의 포워딩 제품이 우리의 SMTP 서버와 그들의 SMTP 서버에서 온 이메일 모두를 지원하길 원합니다. 그러나 그들의 SMTP 서버는 GRPC를 통해 이메일을 보낼 것이라고 하죠!?!?! 이 모든 것이 어떻게 우리의 사고 모델을 다시 한 번 바꾸는지 보겠습니다.\n\n![이미지](/assets/img/2024-05-15-AnatomyOfAProduct_10.png)\n\nSMTP 및 GRPC를 통해 이메일을 수락하기 시작했다는 사실을 알 수 있습니다. 두 인터페이스 모두 EmailStore에 구현된 속도 제한의 이점을 누립니다. 따라서 두 인터페이스가 많은 이메일을 받는 경우에도 EmailStore가 데이터베이스가 넘어가는 것을 방지할 수 있습니다. 게다가, EmailStore에 메트릭을 추가하여 데이터 저장소를 확장해야 하는 시기를 정확히 파악할 수 있습니다.\n\n데이터베이스를 보호하는 또 다른 자주 간과되는 이점은 내부 남용 외에도 외부 남용에서 제공됩니다. 몇 년 전에 파이썬에서 ORM을 사용하는 시스템에서 일했었는데요. 이런 경우에는 상호 작용하는 객체가 메모리 내의 객체인지 데이터베이스의 테이블을 나타내는지를 판별하는 것이 어려운 경우가 많습니다. 그래서 새 기능을 구현할 때 이 객체의 모든 항목을 기쁘게 반복했지만 해당 객체가 데이터베이스로 N+1개의 선택을 보내는 ORM 객체임을 깨달지 못했습니다. 이 기능은 테스트에서 완벽하게 수행되었고 스테이징에서도 잘 실행되었지만 배포하자마자 생산 데이터베이스를 다운시켰습니다.\n\n이와 같은 종류의 남용에 대한 생산 데이터베이스 보호가 제공되었다면 우리는 의도치 않은 데이터베이스 장애 대신 응용 프로그램 성능 저하를 경험했을 것입니다.\n\n# 데이터베이스 전환\n\n과부하된 데이터베이스에 대해 얘기하자면, 저희는 본사의 SMTP 서버와 통합된 이후에 이메일이 EmailStore에 저장되는 양이 거의 두 배로 증가했고 이로 인해 기존 데이터베이스가 스트레스를 받고 있습니다.\n\n다행히도 새로운 본사와의 계약을 통해 클라우드 제공업체의 클라우드 파일 저장 제품에 대한 매우 좋은 협상을 이루었는데, 그들은 우리에게 이메일을 그곳에 저장하길 원합니다. EmailStore 인터페이스가 좋아서 데이터베이스에서 이메일을 저장하고 검색하는 것에서 새로운 파일 저장 제품으로 전환할 수 있습니다.\n\n하지만 잠깐, 어떻게 하면 구름 저장소로 이전된 그 모든 이메일들을 마이그레이션할 수 있을까요. 그것은 정말 많은 양의 데이터입니다. 이메일 중에는 20-50MB 크기인 것도 있습니다! 게다가 고객들은 이전하는 동안에도 수용 가능한 서비스를 기대하고 있습니다! 이 문제를 해결하기 위해, EmailStore 인터페이스로 CloudEmailStore를 구현하고 이전 EmailStore를 OldEmailStore로 이름을 변경합니다. 이제 무엇인가를 찾을 때 옛날 이메일을 찾을 때 OldEmailStore를 호출하고 새로운 이메일을 저장할 때 CloudEmailStore를 호출하는 EmailStoreAdaptor라는 동일한 인터페이스를 구현하는 어댑터를 만듭니다. 그런 다음 이메일을 \"마이그레이션된\" 것으로 표시하는 비동기 마이그레이션 프로세스를 개발하여, 이메일Store 어댑터 인터페이스에게 이미 CloudEmailStore로 마이그레이션된 이메일을 알리고 그곳에서 찾도록 알려줍니다.\n\n![AnatomyOfAProduct_11](/assets/img/2024-05-15-AnatomyOfAProduct_11.png)\n\n이주가 완료된 후에는 EmailStoreMigration 어댑터를 제거하고 CloudEmailStore 구현이 새로운 EmailStore가 됩니다.\n\n# 기적을 일으키는 일꾼\n\n음…… 루틴 유지보수 변경이 ForwardEvaluator에 버그를 도입했는데요. 결과적으로 지난 24시간 동안 이메일을 전달하지 않았습니다!\n\n하지만 모든 게 아득하지는 않습니다. SmtpServer의 훌륭한 감사 로그 덕분에 그 날 받은 모든 이메일의 이메일 ID를 알고 있습니다. 우리가 ForwardEvaluator와 EmailStore를 시스템의 나머지 부분과 추상화했기 때문에 새로운 GRPC 메소드인 ReprocessEmail()를 신속하게 작성하여 사용하여 그 날 받은 모든 이메일 ID를 입력으로 사용하고 재처리할 수 있습니다. 이는 SMTPServer가 모든 받은 이메일을 EmailStore에 저장했기 때문에 작동합니다. 이로써 지난 24시간 동안 받은 모든 이메일 ID의 감사 로그와 함께 재처리하고 전달할 수 있습니다! 이는 다음과 같이 보입니다.\n\n![이미지](/assets/img/2024-05-15-AnatomyOfAProduct_12.png)\n\n이제 남은 것은 오늘 받은 이메일 ID를 감사 로그에서 읽어와 ReprocessEmail()를 호출하여 가능한 전달 여부를 평가하는 외부 프로세스를 작성하는 것이 있습니다. 위기가 회피되었어요!\n\n데이터베이스 쿼리 조합이나 일회성으로 테스트되지 않은 코드 조각을 접속해 모든 처리를 수행하는 대신, 우리는 기존의 코드를 그대로 사용하고 있습니다. 문제 영역별로 잘 정의된 추상화를 활용하고 있으며, 실제 운영에서 충분히 이해하고 테스트한 것을 통해 잘 구성되었습니다. 이 일을 처리하기 위해 우리가 작성한 유일한 새로운 코드는 GRPC 메소드 ReprocessEmail()와 감사 로그를 읽고 ReprocessEmail()를 호출하는 스크립트에 있었습니다.\n\n기존 인터페이스를 재사용함으로써 우리의 재처리 전략이 작동할 것에 대한 큰 신뢰를 얻었습니다. 만약 처음부터 KISS 원칙을 적용하지 않고 도메인 주도 인터페이스를 정의하고 문제를 분리하고 시스템 전반에 데이터 소유권을 할당하는 데 시간을 들이지 않았다면 이것이 가능하지 않았을 겁니다. 축하합니다, 이제 당신은 사무실에서 \"기적을 행하는 사람\"의 호칭을 지닐 수 있습니다. 마음껏 드세요.\n\n# 새 버전 소개\n\n이제 곧 포워딩 제품의 새 버전을 소개할 예정입니다. 그러나 이 게시물이 원래 계획했던 것보다 훨씬 길어졌기 때문에 별도의 게시물로 나누어서 소개할 예정입니다.\n\n다음 게시물은 다음 주에 Medium에서 확인하실 수 있습니다!\n","ogImage":{"url":"/assets/img/2024-05-15-AnatomyOfAProduct_0.png"},"coverImage":"/assets/img/2024-05-15-AnatomyOfAProduct_0.png","tag":["Tech"],"readingTime":12},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-AnatomyOfAProduct_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 시니어/아키텍트/프로그래머 같은 역할이 궁금한거야?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아니면 제품이 개발되는 과정에서 10일마다 새로 작성할 필요가 없이 진행 상황을 살펴보고 싶은 건가? 어쨌든 넌 제자리에 있어.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사는 코드 및 시스템을 설계하는 데 사용한 방법에 대한 설명으로, 제품 수명 동안 테스트 가능성, 변화 속도를 최대화하고 기술 부채를 줄이는 데 도움이 될 것이야. 이 기사는 https://mailgun.com에서 제품을 구축하고 확장하는 경험의 총결이야.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 우리는 상상 속 제품을 디자인, 배포, 확장 및 예상치 못한 새로운 요구사항까지 따라갈 것입니다. 우리는 아주 많은 세부 사항을 건너뛰고 조금씩 뛰어다니겠지만, 좋은 코드 아키텍처가 제품 수명 동안 자산이 될 수 있는 전체적인 관점을 제공하는 것이 목표입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"준비되셨나요? 시작해 봅시다...\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"메타 모델\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 코드 아키텍처를 어떻게 정신적으로 모델링해야 하는지 고민해보겠습니다. 메타 모델은 우리가 정신 모델을 구성하는 추상화의 세부 사항을 이해할 필요없이 시스템 전체에 대해 추론할 수 있게 해줍니다. 여기서 제시하는 정신 모델은 Mailgun에서 코드와 아키텍처를 만들고 추론하는 데 성공적으로 사용되었습니다. 이 생각의 방식은 최대한의 유연성을 제공하고 기술적 부채를 피하고 관리하며 제품 수명 동안 높은 품질의 코드를 유지할 수 있도록 도와줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사에서는 도메인 주도 설계, 추상화, 관심사 분리 및 데이터 소유권 원칙에 영감을 받은 접근법을 소개합니다. 이를 DACO(Domain, Abstract, Concern, Ownership)로 간략히 부르겠습니다. 이러한 원칙 대부분은 새로운 것이 아니며 수년 동안 존재해 왔습니다. 이러한 개념을 숙달하는 것은 좋은 코드와 좋은 아키텍처를 작성하는 데 극히 중요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이메일 전달 제품의 생성을 고려해 보겠습니다. 이제 이 기사의 나머지 부분에서는 데이터, 인터페이스 및 코드 변경이 제품 수명 주기 동안 어떻게 전개될 수 있는지 확인하기 위해 이 제품을 따라가 보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"전달 제품\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 제품에 대한 간단한 CRUD 인터페이스를 고려해 보겠습니다. 이는 사용자가 이메일 전달 제품을 위해 전달 규칙을 생성하고 삭제하는 곳입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_1.png\",\n        alt: \"AnatomyOfAProduct_1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 제품의 가장 간단한 기능을 정의합니다. 이를 통해 다음과 같은 규칙을 생성할 수 있습니다. \\\"from@example.com으로 보낸 이메일을 받으면 이메일을 forward@email.com으로 전달합니다.\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 이러한 규칙을 데이터베이스에 저장하고, 이 서비스 부분을 구성할 인터페이스를 모델링합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_2.png\",\n        alt: \"AnatomyOfAProduct_2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 인지 모델 안에 있는 첫 두 개의 인터페이스는 입력 및 출력의 추상화이기도 합니다. RuleStore는 우리가 사용하는 데이터베이스를 추상화하고 Repository 패턴의 예입니다. 두 번째 추상화는 HttpAPI입니다. HttpAPI를 서비스의 인터페이스로 생각하지 말고 RuleStore에 대한 네트워크 인터페이스로 생각할 수 있습니다. 이것은 주로 RuleStore 메소드를 네트워크에 노출시키는 기능을 하기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런데 왜 우리는 코드를 절차적으로 구성하지 않을까요? 이 인터페이스들은 서비스를 통해 데이터가 통과하는 과정에 실제로 일어나는 절차를 따르지 않는 것 같은데, 왜 이 프로젝트 초기에 이렇게 인터페이스를 사용하여 복잡하게 만들까요? 이러한 추상화가 왜 이렇게 중요한지 이해하기 위해, 데이터(우리의 데이터인 규칙)가 우리 시스템을 통해 어떻게 전달되는지를 엄격히 절차적인 관점에서 살펴보겠습니다. 새 규칙을 생성할 때 우리가 하는 일에 대한 시각화가 여기 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Procedural 모델에서 사용자는 API에 따라 JSON 규칙을 작성하고 HTTP Post를 통해 보냅니다. 그런 다음 우리는 규칙을 유효성 검사합니다(즉, 이메일 주소가 올바른가?) 그리고 그것을 데이터베이스에 저장합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HttpAPI 핸들러가 JSON rule을 받을 때, 구조체로 un-marshal하고 규칙을 유효성 검사한 후 데이터베이스에 저장하기 전에 정리해야 할 이유가 뭐죠? 이 작업을 두 가지 다른 인터페이스와 여러 메소드로 나눠서 사용하는 이유가 뭘까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 절차적 논리는 심지어 HttpAPI 핸들러를 나쁜 데이터로부터 나머지 서비스를 보호하는 문지기로 생각한다면 직관적일 수도 있습니다. 그러나 여기서 제가 언급하고 싶은 두 번째 중요한 개념을 소개하고 싶습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데이터 소유권\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 스스로에게 물어야 합니다. 규칙의 올바른 데이터를 갖는 책임은 누구일까요? 규칙은 누가 확보하고 있을까요? 누가 규칙과 데이터베이스를 남용으로부터 보호할까요? 이러한 질문의 연속은 정신적 모델을 구성할 때 중요합니다. 왜냐하면 누가 무엇을 소유하는지 명확히 한다면, 유효성 검사를 통합하고 데이터를 보호하는 작업을 하나의 위치에 집중시킬 수 있고 정신적 모델을 단순화할 수 있기 때문입니다. 소유권에 대한 이 아이디어는 데이터가 저장된 데이터베이스에서 쉼 상태에서 규칙을 소유하는 저장소 패턴과 잘 맞습니다. 또한 데이터의 측면을 소유하는 파이프라인과 함께 사용될 때, 데이터가 변환될 때 데이터의 소유권이 시스템의 다른 모듈로 넘어갈 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 HTTPAPI 인터페이스가 네트워크에서 데이터의 소유권을 가져오기 때문에 데이터는 일종의 직렬화 형식에서 코드 구조로 변환되기 때문에 데이터를 보유해야 한다는 주장도 할 수 있습니다. 그러나 데이터는 RuleStore로 향하는 길목에서 HttpAPI를 통과하기만 합니다. 어떤 면에서 HttpAPI는 데이터의 변환기일 뿐입니다. HttpAPI의 유일한 관심사는 HTTP를 통해 JSON으로 데이터를 가져 와 RuleStore가 이해할 수 있는 구조로 변환하는 것입니다. HttpAPI를 네트워크 어댑터로 생각할 수 있습니다. 이를 통해 HttpAPI와 RuleStore가 서비스 전반의 입력과 출력을 추상화하는 동시에 내부 모듈에 대한 추상화도 될 수 있음을 알 수 있습니다. 이러한 추상화를 기반으로 코드를 구축하면 API에 새로운 기능이 추가될 경우에 매우 유용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 KISS (Keep It Simple Stupid)에 따르면 작동하는 가장 간단한 것을 하라고 합니다. 그렇다면 /v1/forwards의 HTTP 핸들러에서 JSON을 해석하고 유효성을 검사하며 데이터를 데이터베이스에 저장하는 것이 최선일 것입니다. 이 인터페이스와 소유권 문제가 뭐지?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설명을 하자면, 우리가 어떻게 이러한 인터페이스/추상화가 장기적으로 어떻게 우리에게 이익을 가져다주는지 살펴봄으로써 전방 프로젝트의 수명주기를 계속해보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제품 디자인으로 다시 돌아와서, 우리가 규칙 저장소가 규칙을 소유하기로 결정했기 때문에 데이터베이스에 저장하기 전에 규칙을 유효성 검사해야 합니다. 우리는 규칙이 데이터가 부족하거나 잘못되었을 때 데이터베이스를 보호하기 위해 \\\"보호\\\"한다고 말합니다. 소유권을 반영하기 위해 다이어그램을 업데이트해보겠습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-AnatomyOfAProduct_4.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희 제품의 다음 주요 부분은 고객이 이메일을 전달하기 위한 인터페이스를 제공하는 것입니다. 이메일을 받고 저장하며 규칙과 일치하는 이메일을 전달할 SMTP 서버가 필요합니다. 이게 어떻게 보일지 다이어그램으로 살펴봅시다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-AnatomyOfAProduct_5.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서도 SmtpServer를 통해 응용 프로그램 입력을 추상화하고, 그 이메일을 MIME 형식으로 저장하는 EmailStore가 있습니다. 다음으로는 이메일 전달 규칙을 찾은 RuleStore에 일치하는지 여부를 판단하는 ForwardEvaluator가 있습니다. 이메일이 일치한다면 이메일을 전달하는 데 사용하는 SmtpClient 출력 추상화를 사용하여 EmailStore를 이용하여 저장된 이메일을 검색하고 대상 SMTP 서버로 보냅니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데이터\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 제품의 주요 데이터 형식은 Rule과 Email 두 가지가 있어요. Rule은 변환 기준을 제공하고, Email은 우리가 변환하는 대상입니다. 우리는 To 주소를 MIME에서 변경하는 것이므로 \\\"변환\\\"이라 말해요. 우리는 우아한 이메일 수신자로서, MIME에 대신 받은 헤더를 추가한 후 Email을 적합한 SMTP 서버에 전달해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SMTP를 통해 이메일을 받으면, SMTP 프로토콜을 통해 제공되는 수신자(To)와 발신자(From) 정보를 받게 되고, 그 후에 이메일의 본문 또는 MIME을 받게 됩니다. 우리는 MIME(여러 메가바이트의 데이터가 될 수 있어요)를 EmailStore에 전달하여 Email 데이터베이스에 유지하게 합니다. EmailStore는 이메일 ID를 생성하고, 이후에는 EmailStore에서 이메일을 검색하는 데 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SMTP 서버가 이메일을 받으면, 이메일의 본문(MIME)과 수신자와 발신자와 같은 이메일에 대한 몇 가지 메타데이터를 받습니다. 이 데이터를 다음 구조로 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_6.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 메타데이터 구조는 이메일이 데이터베이스의 규칙과 일치하는지 여부를 결정하기 위해 ForwardEvaluator에 전달되는 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"제품 출시\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재, 우리는 최소한이지만 완벽한 이메일 전달 제품을 갖고 있습니다. 제품을 출시하고 나서 우리 고객들이 행복하며 우리는 축하로 브리스킷을 구웁니다. (저는 텍사스에 살고 있으니, 이것이 우리가 하는 일입니다)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제품을 발표한 직후에 규칙 일치 및 전송이 새 이메일 메시지를 받는 능력을 늦추고 있다는 것을 알게 되었습니다. 이를 따라가기 위해 규칙 처리와 SMTP 전달을 수평 확장해야 합니다. 두 개의 스레드 풀을 구현해 보겠습니다. 첫 번째는 규칙을 병렬로 처리할 수 있는 ForwardEvaluator 스레드 풀입니다. 그 다음으로, 메시지 전달을 처리할 SmtpClients 스레드 풀을 생성합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_7.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"워커 풀에 작업을 대기시키기 위해 큐(고랭채널)를 사용합니다. ForwardEvaluator 풀은 이메일 메타데이터를 입력으로 받습니다(전달 이메일 주소와 일치시키기 위해 사용되는 발신 및 수신 헤더가 포함됨). 그런 다음 일치가 발생하면 ForwardEvaluator가 SmtpClient 워커 풀의 워커를 통해 전달을 위해 Queue(SmtpJob)를 호출합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 실행하기 위해 실제로 변경된 코드가 매우 적다는 점이 흥미롭습니다. 이미 각 문제 영역 주변에 인터페이스가 있었기 때문에 대부분의 코드가 추가적입니다. 간단하게 인터페이스를 워커 풀에 넣었을 뿐인데 이제 서버가 허용하는 대로 CPU 수를 확장할 수 있습니다. 그러나 계속 진행하고 제품이 성장함에 따라 이러한 인터페이스가 어떻게 도움이 되는지 계속 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 6개월이 지난 지금은 점점 더 큰 고객을 유치하고 있어요. 어떤 고객들은 60,000부터 100,000개의 이메일 주소를 전달하고 싶어해요. 그리고 기술을 잘 모르시는 다른 고객들은 대량으로 이메일 주소를 가져오기를 요청하고 있어요. 그래서 우리는 CSV 업로드 엔드포인트를 추가하기로 결정했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 모델을 업데이트해서 현재 디자인과 어떻게 맞아 떨어지는지 살펴봐요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_8.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에서 핵심 제품에는 크게 변화가 없고, 검증이 RuleStore에서 발생하기 때문에 CsvImporter에 중복된 검증 코드가 없다는 게죠—이렇게 동작하는 것을 보세요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단순히 새로운 입력 추상화를 추가하고 HTTP를 통한 CSV 가져오기를 처리하고 있습니다. 우리는 소유권과 입출력 인터페이스를 정확하게 식별했기 때문에 이 새로운 기능 변경은 현재 코드를 리팩토링할 필요가 없습니다. 새로운 문제 도메인을 위한 새로운 추상화와 HttpAPI에 대한 새로운 핸들러만 추가하면 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 우리는 소유권이 작용하는 것을 볼 수 있습니다. CsvImporter는 CSV 파일(데이터)을 업로드할 때 해당 CSV 파일의 소유권을 가지고, 그 CSV 파일을 규칙으로 변환한 후에 그 규칙을 RuleStore에 저장합니다. 이것은 시스템을 흐르는 데이터이며, 변환되는 데이터의 소유권이 데이터의 변환이 발생한 후에 전달되는 것입니다. 각각의 그 소유권 이전과 변환은 별도의 문제 도메인이므로 하나의 문제 도메인에 여러 변환을 과중하게 부담시키지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"당신이 생산 라인의 비유를 사용하고 싶다면, 각 변환이 생산 라인 위의 각 정거장이라는 것을 생각해보세요. 각 정거장에서는 다음 정거장으로 이동하기 전에 자동차(또는 우리 경우 데이터)에 대해 무언가를 추가하거나 변경합니다. 이렇게 함으로써, 우리는 우리의 인지 부하와 코드를 간단하게 만듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"#成長의 고통\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새로운 CSV 가져오기 기능이 추가되었고, 대형 고객이 추가되면서, 저희의 전달 제품은 성공의 압박을 느끼기 시작했습니다. 처리 시간이 늘어나서 계속 확장하고자 한다면 성능을 개선해야 합니다. 저희의 지표에 따르면 RulesStore가 HttpAPI와 ForwardEvaluator 양쪽에서 일치하는 규칙을 찾을 때 고전을 겪고 있습니다. 캐시를 추가할 시간인데, 어디에 넣어야 할까요? 데이터 소유 정신 모델에 따라 캐시는 규칙 저장소와 함께 있어야 합니다. RuleStore가 데이터와 데이터베이스를 소유하고 보호하기 때문입니다. 게다가 RuleStore 추상화는 캐시가 언제 무효화되어야 하는지 알고 있으며 규칙이 삭제되거나 업데이트될 때 캐시를 무효화할 수 있습니다. HttpAPI와 ForwardEvaluator는 캐시에서 직접적으로 알거나 접근하지 않아도 성능 개선을 활용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에서는 RuleStore 인터페이스를 추상화하고 RuleStore 앞에 캐시를 놓았습니다. 캐시를 RuleStore 내부에 캡슐화하는 것도 완전히 유효하지만, 이러한 방식으로 구현하는 것에는 몇 가지 장점이 있습니다. 첫째, 이 분리는 코드 변경 없이 인메모리 캐시에서 memcached나 redis로 캐시 구현을 변경할 수 있게 합니다. 둘째, 이는 Groupcache를 사용하여 캐시 요청을 응용 프로그램의 다른 인스턴스로 전달하고 RuleStore 작업을 수행하도록 할 수 있어서, 그룹 문제를 피할 수 있는 특수한 기능을 수행할 수 있습니다. 이러한 두 가지 이점 외에도 캐시 코드와 데이터베이스 코드의 분리로 인해 한 쪽을 변경하더라도 다른 쪽에 영향을 미치지 않게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 또 다른 문제점을 알아차렸습니다. 일부 고객 또는 인터넷에 있는 악의적인 사용자들이 SMTP 서버를 남용하기 시작했습니다! 매 초 수백 메가바이트의 데이터를 보내고 EmailStore를 압도하고 있습니다. EmailStore를 남용으로부터 보호해야 합니다! 전통적인 지혜라면 SMTP 서버를 통해 고객이 보낼 수 있는 바이트 수를 제한해야 한다고 할 것입니다. 그러나 데이터 소유 관점에서 생각한다면 EmailStore가 데이터를 소유하는만큼 데이터를 남용으로부터 보호해야 하는 것이 맞지 않을까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SMTP 서버는 데이터 전송을 느리게 만들 수 있고 해야 합니다. 그러나 이는 이메일 스토어가 압도되고 있다고 표시될 때에만 이루어집니다. 데이터 전송 속도 제한 결정은 네트워크로부터 이메일 스토어를 추상화하는 인터페이스(SmtpServer라고 함)가 아니라 이메일 스토어로부터 나와야 합니다. 만약 이 결정에 대해 헷갈리신다면 계속 읽어보시면 그 의미가 분명해질 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"성공의 대가\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 우리 제품이 매우 성공적이어서 더 큰 이메일 처리 회사에 인수되고 있습니다! 그러나 새로운 모회사는 내부 간 서비스 통신을 위해 모든것을 GRPC로 결정했고, 그들은 우리의 포워딩 제품이 우리의 SMTP 서버와 그들의 SMTP 서버에서 온 이메일 모두를 지원하길 원합니다. 그러나 그들의 SMTP 서버는 GRPC를 통해 이메일을 보낼 것이라고 하죠!?!?! 이 모든 것이 어떻게 우리의 사고 모델을 다시 한 번 바꾸는지 보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_10.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SMTP 및 GRPC를 통해 이메일을 수락하기 시작했다는 사실을 알 수 있습니다. 두 인터페이스 모두 EmailStore에 구현된 속도 제한의 이점을 누립니다. 따라서 두 인터페이스가 많은 이메일을 받는 경우에도 EmailStore가 데이터베이스가 넘어가는 것을 방지할 수 있습니다. 게다가, EmailStore에 메트릭을 추가하여 데이터 저장소를 확장해야 하는 시기를 정확히 파악할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터베이스를 보호하는 또 다른 자주 간과되는 이점은 내부 남용 외에도 외부 남용에서 제공됩니다. 몇 년 전에 파이썬에서 ORM을 사용하는 시스템에서 일했었는데요. 이런 경우에는 상호 작용하는 객체가 메모리 내의 객체인지 데이터베이스의 테이블을 나타내는지를 판별하는 것이 어려운 경우가 많습니다. 그래서 새 기능을 구현할 때 이 객체의 모든 항목을 기쁘게 반복했지만 해당 객체가 데이터베이스로 N+1개의 선택을 보내는 ORM 객체임을 깨달지 못했습니다. 이 기능은 테스트에서 완벽하게 수행되었고 스테이징에서도 잘 실행되었지만 배포하자마자 생산 데이터베이스를 다운시켰습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이와 같은 종류의 남용에 대한 생산 데이터베이스 보호가 제공되었다면 우리는 의도치 않은 데이터베이스 장애 대신 응용 프로그램 성능 저하를 경험했을 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데이터베이스 전환\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"과부하된 데이터베이스에 대해 얘기하자면, 저희는 본사의 SMTP 서버와 통합된 이후에 이메일이 EmailStore에 저장되는 양이 거의 두 배로 증가했고 이로 인해 기존 데이터베이스가 스트레스를 받고 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다행히도 새로운 본사와의 계약을 통해 클라우드 제공업체의 클라우드 파일 저장 제품에 대한 매우 좋은 협상을 이루었는데, 그들은 우리에게 이메일을 그곳에 저장하길 원합니다. EmailStore 인터페이스가 좋아서 데이터베이스에서 이메일을 저장하고 검색하는 것에서 새로운 파일 저장 제품으로 전환할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 잠깐, 어떻게 하면 구름 저장소로 이전된 그 모든 이메일들을 마이그레이션할 수 있을까요. 그것은 정말 많은 양의 데이터입니다. 이메일 중에는 20-50MB 크기인 것도 있습니다! 게다가 고객들은 이전하는 동안에도 수용 가능한 서비스를 기대하고 있습니다! 이 문제를 해결하기 위해, EmailStore 인터페이스로 CloudEmailStore를 구현하고 이전 EmailStore를 OldEmailStore로 이름을 변경합니다. 이제 무엇인가를 찾을 때 옛날 이메일을 찾을 때 OldEmailStore를 호출하고 새로운 이메일을 저장할 때 CloudEmailStore를 호출하는 EmailStoreAdaptor라는 동일한 인터페이스를 구현하는 어댑터를 만듭니다. 그런 다음 이메일을 \\\"마이그레이션된\\\" 것으로 표시하는 비동기 마이그레이션 프로세스를 개발하여, 이메일Store 어댑터 인터페이스에게 이미 CloudEmailStore로 마이그레이션된 이메일을 알리고 그곳에서 찾도록 알려줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_11.png\",\n        alt: \"AnatomyOfAProduct_11\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이주가 완료된 후에는 EmailStoreMigration 어댑터를 제거하고 CloudEmailStore 구현이 새로운 EmailStore가 됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"기적을 일으키는 일꾼\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"음…… 루틴 유지보수 변경이 ForwardEvaluator에 버그를 도입했는데요. 결과적으로 지난 24시간 동안 이메일을 전달하지 않았습니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 모든 게 아득하지는 않습니다. SmtpServer의 훌륭한 감사 로그 덕분에 그 날 받은 모든 이메일의 이메일 ID를 알고 있습니다. 우리가 ForwardEvaluator와 EmailStore를 시스템의 나머지 부분과 추상화했기 때문에 새로운 GRPC 메소드인 ReprocessEmail()를 신속하게 작성하여 사용하여 그 날 받은 모든 이메일 ID를 입력으로 사용하고 재처리할 수 있습니다. 이는 SMTPServer가 모든 받은 이메일을 EmailStore에 저장했기 때문에 작동합니다. 이로써 지난 24시간 동안 받은 모든 이메일 ID의 감사 로그와 함께 재처리하고 전달할 수 있습니다! 이는 다음과 같이 보입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-AnatomyOfAProduct_12.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 남은 것은 오늘 받은 이메일 ID를 감사 로그에서 읽어와 ReprocessEmail()를 호출하여 가능한 전달 여부를 평가하는 외부 프로세스를 작성하는 것이 있습니다. 위기가 회피되었어요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터베이스 쿼리 조합이나 일회성으로 테스트되지 않은 코드 조각을 접속해 모든 처리를 수행하는 대신, 우리는 기존의 코드를 그대로 사용하고 있습니다. 문제 영역별로 잘 정의된 추상화를 활용하고 있으며, 실제 운영에서 충분히 이해하고 테스트한 것을 통해 잘 구성되었습니다. 이 일을 처리하기 위해 우리가 작성한 유일한 새로운 코드는 GRPC 메소드 ReprocessEmail()와 감사 로그를 읽고 ReprocessEmail()를 호출하는 스크립트에 있었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기존 인터페이스를 재사용함으로써 우리의 재처리 전략이 작동할 것에 대한 큰 신뢰를 얻었습니다. 만약 처음부터 KISS 원칙을 적용하지 않고 도메인 주도 인터페이스를 정의하고 문제를 분리하고 시스템 전반에 데이터 소유권을 할당하는 데 시간을 들이지 않았다면 이것이 가능하지 않았을 겁니다. 축하합니다, 이제 당신은 사무실에서 \\\"기적을 행하는 사람\\\"의 호칭을 지닐 수 있습니다. 마음껏 드세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"새 버전 소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 곧 포워딩 제품의 새 버전을 소개할 예정입니다. 그러나 이 게시물이 원래 계획했던 것보다 훨씬 길어졌기 때문에 별도의 게시물로 나누어서 소개할 예정입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 게시물은 다음 주에 Medium에서 확인하실 수 있습니다!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-AnatomyOfAProduct"},"buildId":"j1jNlyrKP6vysiJTgEH8g","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>